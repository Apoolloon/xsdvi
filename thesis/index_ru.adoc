= Визуализация XML схемы
Václav Slavětínský <https://sourceforge.net/u/vaclaforge/profile/>;
květen 2008
:doctype: book
:sectnums:
:toc: left
:toclevels: 4
:icons: font
:experimental:

== Введение

XML позволяет разработчикам создавать собственные форматы для хранения и обмена данными, следуя правилам синтаксиса.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное объявление и документация,
то есть описание, которое позволит им обмениваться, определяться и использоваться. Для этого было разработано несколько языков.
К ним относятся W3C _XML schema_, DTD (_Document Type Definition_) и Oasis _Relax NG_.

Благодаря интеграции с другими стандартами на основе XML, а также широким возможностям и поддержке крупных компаний-разработчиков программного обеспечения - часто используют схему XML.
Однако его спецификация (см. <<XSD1>>, <<XSD2>>) довольно сложна, и схемы могут стать запутанными для пользователя.
Причиной этого являются различные возможности написания, вытекающие из объектных элементов этого языка.
Схема XML позволяет использовать, расширять и ограничивать типы данных;
создание ссылок на элементы, атрибуты и группы элементов или атрибутов;
элементы могут быть заменены механизмом групп замещения;
также можно импортировать, вставлять и переопределять внешние схемы или их части.

Тема данной работы - визуализация XML-схем.
Цель состоит в том, чтобы спроектировать и реализовать приложение, которое на входе получит экземпляр XML-схемы W3C, а на выходе бы
сохранила свое интерактивное графическое представление в формате SVG (_Scalable Vector Graphics_) <<SVG>>.
Это графическое представление или диаграмма могут использоваться как часть документации, соответствующей схеме XML.
На диаграмме будут показаны структуры используемых элементов и атрибутов, их имена, пространства имен,
типы данных и дополнительная информация - количество элементов, обязательное / необязательное использование атрибутов, определенные уникальные, первичные и внешние ключи и т. д.
Это также позволит просматривать структуры, открывать и скрывать подгруппы элементов и атрибутов, используя _ECMAScript_.
Важными требованиями являются то, чтобы графика была интерактивной, интуитивно понятной и понятной,
потому что целью работы является главным образом облегчить ориентацию и понимание XML-схем их пользователями - создателями XML-документов.

Файлы SVG можно открывать в современных веб-браузерах (для некоторых необходимо установить плагин SVG)
или в приложениях, предназначенных для просмотра или редактирования векторной графики.
Многие из них находятся в свободном доступе. Векторная графика использует геометрические объекты для представления изображений, что облегчает программное редактирование.
Однако некоторые ограничения возникают из-за сложности обработки и медленной реализации ECMAScript в браузерах.
Это становится очевидным в больших схемах, точнее в больших структурах описанных документов.
(большие структуры могут быть определены даже с относительно короткой схемой).
Ограничение отражается в более медленной реакции на события и, как правило, в более медленном построении диаграммы.
В этой области мы можем только надеяться на лучшую поддержку в будущем.

Само приложение будет написано на языке программирования Java и будет использовать пакеты синтаксического анализатора _Xerces_,
которая является реализацией интерфейса с открытым исходным кодом, определенного в <<XSD1>> и <<XSD2>>.
Для запуска вам необходимо установить среду исполнения _Java Runtime Environment_.
Сегодня, однако, JRE является общей частью большинства компьютеров.
С помощью Java приложение может быть легко перенесено на разные платформы.

Позвольте мне кратко упомянуть структуру работы.
Цель второй главы - познакомить читателя с технологиями, используемыми в приложении, и способами их использования.
К ним относятся XML-схема W3C, масштабируемая векторная графика, ECMAScript и объектная модель документа, каскадные таблицы стилей, язык Java.

Специальная глава (третья) посвящена возможностям загрузки и интерпретации модели XML-схемы.
Существует описание нескольких реализаций с открытым исходным кодом абстрактной модели данных XML-схемы и их оценка.
Я наконец выбрал процессор Xerces2-J из этих реализаций.
Он создает основу программы, предоставляя легкий доступ к компонентам схемы и их свойствам.

Четвертая глава посвящена разработке графической модели.
Сначала выбирается соответствующий тип, логическая модель; она четко отображает структуру определенных документов XML.
Ниже приведен анализ отдельных элементов - графических символов компонентов схемы - и их структуры.
Для каждого символа вы найдете изображения, значения и описания параметров, относящиеся к свойствам компонентов схемы.
Описан механизм интерактивности модели и возможность дополнительной модификации внешнего вида с помощью внешнего стиля.

Цель пятой главы - разработать алгоритм обработки схемы.
Вам нужно пройтись по некоторым компонентам и извлечь данные визуализации из их свойств.
Обработка компонентов, значение которых также описано здесь, обеспечивается отдельными методами.
Они вызывают друг друга, обмениваются параметрами и создают графические символы для последующего сохранения в файл SVG.

В заключение постараюсь подвести итоги работы и указать, где можно скачать приложение.

== Используемые технологии

=== XML-схема

XML, _Extensible Markup Language_, расширяемый язык разметки, позволяет разработчикам создавать свои собственные форматы
для хранения и обмена данными. Это создает новые словари пунктов - элементов и их свойств(качеств) - атрибутов.
Если мы хотим автоматически обрабатывать и проверять эти форматы, нам нужно их официальное информация и документация,
то есть описание, которое позволяет совместно использовать, определять и использовать словари.

_XML схема_
    footnote:[Второе издание датировано 28 октября 2004 г., первое было утверждено 2 мая 2001 г.]
является спецификацией, выпущенной консорциумом W3C.
    footnote:[Консорциум World Wide Web, официальный сайт. http://www.w3.org/]
Определяет объектно-ориентированный язык, который можно использовать для формального описания документов XML;
он предоставляет средства для определения их структуры, содержания и семантики.
В частности, мы можем использовать схему для определения элементов и атрибутов, применимых к документу, включая их структуру - взаимное погружение и совмещение;
мы также можем указать тип данных для содержимого элемента или атрибута, значений по умолчанию и других ограничений целостности.
К ним относятся уникальные ключи (_unique_), первичные ключи (_key_) и внешние ключи (_keyref_), ссылающиеся на них.

Схему XML часто сравнивают с другим распространенным языком схемы - DTD, _Document Type Definition_.
Это уже было включено в спецификацию XML 1.0 W3C <<XML>>.
Наиболее важные различия заключаются в том, что DTD использует свой собственный синтаксис, а схема XML является приложением XML, то есть использует его синтаксис.
Другой причиной выбора схемы XML является возможность назначения типов данных для атрибутов и содержимого элементов.
У DTD не было этого базового свойства, поэтому все значения обрабатывались как текстовые строки.
Также не было возможности работать с пространствами имен.
Однако DTD все еще широко используются, главным образом для простоты.

Спецификация схемы XML и ее нотация XML являются сложными, а в некоторых местах довольно сложными для понимания и использования.
Поэтому были разработаны и другие языки: _Relax NG_ с общим (XML) и компактным синтаксисом и _Schematron_ с другим подходом - для проверки правил.
Однако схема XML имеет самое широкое применение, в том числе и потому, что она поддерживается крупными компаниями-разработчиками программного обеспечения (Microsoft, IBM, Oracle, Sun).

Схема XML формализует ограничения, выраженные в виде правил или структурных моделей, которым соответствует определенный класс документа XML.
Схемы часто служат инструментами проектирования, устанавливая структуру, на которой могут быть построены конкретные реализации.
Существует несколько типичных областей применения схем.
В основном это валидация, документирование, запросы, биндинг данных и редактирование данных <<XSD-VLIST>>:

* _Валидация_ означает проверку XML-документа на соответствие схеме.
    Он часто используется для управления доступом XML к приложению.
    Он действует как фильтр; документы, соответствующие схеме, будут переданы, другие не будут использоваться.
    Это внешнее управление значительно упрощает приложения, которые в противном случае должны были бы обрабатывать многие исключения, встречающиеся в
    обработка неудовлетворительных входных данных XML.

* _Документирование_ означает описание в виде XML-документа.
    Это формально и машиночитаемо. Поскольку схема XML является документом XML,
    формальная документация может быть легко преобразована в удобочитаемую,
    например, используя преобразования XSLT или другие преобразования.
    Также приложение, которое является результатом этой дипломной работы бакалавра, выполняет такое преобразование в изображение

* Схемы обеспечивают поддержку _query_, поиск содержимого в документах XML.
    Это можно сделать без них, кроме дополнительной информации о структуре и типах данных
    поможет ускорить и упростить поиск и сортировку и сопоставление.
    Использование можно найти на языках _XPath 2.0_, _XSLT 2.0_, _XQuery 1.0_.

* XML-схемы используются с самого начала для _биндинга данных_.
    Это означает преобразование данных, содержащихся в документах XML, в структуры конкретных приложений,
    такие как объекты в объектно-ориентированных системах и реляционные таблицы систем реляционных баз данных.
    Схемы предоставляют дополнительную информацию о типах данных, которые преобразуются в типы данных приложения.

* Как правило, схемы обычно используют для _редактирования_ XML-документов. Например, эта работа взята из _DocBook_,
    который также является применением XML. Редактор, который я использую, дает мне выбор элементов,
    которые допустимы на месте согласно схеме. Это значительно облегчает работу.
    Редактор использует DTD DocBook, предоставляя информацию о структуре,
    Кроме того, схемы XML предоставляют информацию о типах данных.


[float]
==== Компоненты схемы

Процессор схемы XML, соответствующие спецификации W3C <<XSD1>>,
должен работать с информацией, содержащейся в диаграмме, как описано в спецификации.
Схема XML рассматривается здесь как абстрактная модель данных концептуального уровня, независимая от реализации.
Модель данных состоит из отдельных, точно определенных компонентов – _komponent_.
Каждый из них включает в себя описание представления  XML, свойства и ограничения, описание правил проверки,
обращения к PSVI (_Post Schema Validation Infoset_),
    footnote:[Это XML infoset (набор информации), дополнен дополнительной информацией о типе отдельных пунктов – элементов,
        атрибутов, обычных узлов.]
и любые встроенные экземпляры этих компонентов.

Определение следующее:
    "`_Компонент схемы_ - это общий термин, который представляет строительные элементы
      составляющие модель данных абстрактной схемы... _XML Схема_ - это набор компонентов схемы.`"
    footnote:[XML Schema Abstract Data Model. http://www.w3.org/TR/xmlschema-1/#concepts-data-model]

Существует 13 видов компонентов, которые можно разделить на 3 группы.
_Приложение будет работать с ними, как описано в главе <<XSD-PROCESSING>>._
Чтобы быстро понять отношения между компонентами, используйте диаграмму <<DIAGRAM_KOMPONENT>>.
    footnote:[там же.]

[[DIAGRAM_KOMPONENT]]
.Диаграмма компонент XML схемы
image::images/components.gif[]

Первичные компоненты могут или должны быть названы:

* определение простых типов (_Simple type definitions_),
* определение сложных типов (_Complex type definitions_),
* декларирование атрибута (_Attribute declarations_),
* декларирование элемента (_Element declarations_).

Вторичные компоненты должны именоваться:

* определение групп атрибутов (_Attribute group definitions_),
* определение ограничений идентичности (_Identity-constraint definitions_),
* определение группы моделей (_Model group definitions_),
* декларирование нотации (_Notation declarations_).

Вспомогательные компоненты обеспечивают доступ к другим компонентам. Они зависят от контекста:

* аннотирование (_Annotations_),
* модельные группы (_Model groups_),
* гранулы (_Particles_),
* символы подстановки (_Wildcards_),
* использование атрибутов (_Attribute Uses_).


=== SVG

_Scalable Vector Graphics_, Масштабируемая векторная графика была создана на основе консорциума W3C.
Спецификации составляют основу разработки SVG 1.1 <<SVG>>.
Помимо нее, однако, есть много других:
_SVG Tiny 1.2_,
_SVG Mobile 1.1_,
_SVG Print_,
_SVG Filters_,
_SVG Requirements_.
Их тематика - это язык для описания двумерной графики и графических приложений с использованием XML.
Это векторная графика, которая использует геометрические объекты для представления изображений.
Это дает возможность масштабирования - уменьшения и увеличения - без потери качества;
объекты, составляющие изображение, различаются, и полученные файлы обычно занимают меньше места, чем файлы растровых изображений.
Само собой разумеется, что векторная графика подходит только для некоторых типов изображений, таких как символы, диаграммы или графики.
_Результатом исполнения приложения, которое является предметом этой работы, будет диаграмма схемы XML в SVG._

Формат SVG был разработан главным образом для использования в Интернете,
в наши дни это делает его возможным открыть прямо в браузерах Mozilla Firefox, Opera;
в MS Internet Explorer к сожалению, после установки соответствующего плагина (Adobe SVG Viewer).
Формат также поддерживается в коммерческих (Adobe Illustrator, CorelDraw) и open source (Inkscape, Sodipodi) редакторов.

SVG предоставляет три типа графических объектов.
Это векторные графические фигуры, такие как контуры, состоящие из линий и кривых, изображений и текста.
Эти объекты можно группировать, преобразовывать, предварительно отображать и назначать стили.
Другие функции включают в себя вложенные преобразования, обрезание объектов по путям,
альфа-маскирование, фильтрацию изображений и шаблоны объектов.

Получающиеся изображения могут быть интерактивными и динамическими.
Анимации могут быть определены и выполнены декларативно с использованием специальных элементов SVG или скриптов.
Все элементы, атрибуты и свойства доступны для скриптовых языков через SVG _Document Object Model_ (DOM).
K любому графическому объекту могут быть назначены разные обработчики событий, такие как onmouseover, onclick.
footnote:[Наведение курсора мыши.]

Кроме того, SVG может быть встроен в другие форматы XML с использованием технологии пространства имен (_namespace_).
Совместимость также обеспечивается в том смысле, что скрипты могут выполняться, например, на XHTML
(_Extensible HyperText Markup Language_) веб-странице, на которой были вставлены элементы SVG.
Точно так же легко использовать каскадные таблицы стилей (_Cascading Style Sheets_, CSS) для описания внешнего вида отдельных объектов.

[float]
==== Элементы, используемые в выходных данных приложения

Ниже приведено краткое описание элементов SVG, используемых приложением для графического представления схемы.
Элементы также содержат некоторые важные атрибуты.
Кроме того, необходимы общие атрибуты: [.property]`id` для уникальной идентификации элемента в документе и [.property]`class` назначения элемента определенной группе, которой затем может быть назначен стиль.
Пример конкретного приложения можно найти во вложении <<EXAMPLES-SVG-XML>>.

==== <svg>
footnote:[http://www.w3.org/TR/SVG11/struct.html#NewDocument]

Фрагмент документа SVG состоит из любого количества элементов SVG, заключенных в тег `<svg>`
В нашем случае это будет не фрагмент, а отдельный документ, корневым элементом которого будет `<svg>`
Кроме обычных атрибутов ([.property]`id`, [.property]`class`) здесь они будут:

* [.property]`xmlns` – декларация пространства имен,
* [.property]`onload` – запускает скрипт, когда этот элемент загружен.


==== <title>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DescriptionAndTitleElements]

Заголовок, короткая подпись может быть добавлена к каждому контейнеру или графическому элементу.
Он не будет отображаться напрямую, но может отображаться как _tooltip_.
Заголовок, добавленный `<svg>` элементом, отображается браузером в строке заголовка.

==== <script>
footnote:[http://www.w3.org/TR/SVG11/script.html#ScriptElement]

Используется для вставки скрипта, будет включен как дочерний элемент для `<svg>` элемента.
Сам скрипт должен быть обернут секцией `<![CDATA[ skript ]]>`,
что бы интерпретатор понимал содержимое только как текст и не ищет теги.

* Атрибут [.property]`type` – указывает скриптовый язык, значение MIME типа, в случае ECMAScript -  `text/ecmascript`.

==== <defs>
footnote:[http://www.w3.org/TR/SVG11/struct.html#DefsElement]

Содержит элементы, на которые есть ссылки в документе.
Содержимое может совпадать с контейнером `<g>`, разница в том, что перечисленные здесь графические объекты не будут отображаться напрямую.
Определения в выходных данных приложения включают элемент стиль `<style>` и часто используемые символы `<symbol>`

==== <style>
footnote:[http://www.w3.org/TR/SVG11/styling.html#StyleElement]

Используется для вставки стиля, который описывает расположение объектов и их групп.
Опять же, будет уместно обернуть стиль разделами `<![CDATA[ styl ]]>`

* Атрибут [.property]`type` – указывает язык стиля, значение - MIME-типа,
    footnote:[RFC спецификация 2045: Multipurpose Internet Mail Extensions. http://www.ietf.org/rfc/rfc2045.txt]
    в каскадном стиле `text/css`.


==== <symbol>
footnote:[http://www.w3.org/TR/SVG11/struct.html#SymbolElement]

Символ определяет графический шаблон, который не отображается до тех пор,
пока он не будет использован в документе SVG элементом  `<use>`.
Определение символов имеет смысл для часто используемых объектов.
В этом приложении будет два  – _plus_ и _minus_ для раскрытия и скрытия поддерева графических символов (блоков).
Будут использованы только общие атрибуты.

==== <use>
footnote:[http://www.w3.org/TR/SVG11/struct.html#UseElement]

Относится к другому элементу и указывает, что его графическое содержимое должно быть
включено и отображено там, где находится элемент `<use>` указан.
Среди них могут быть графические элементы, `<g>`, `<svg>`, `<use>` и (в нашем случае только) `<symbol>`.
В дополнение к обычным атрибутам здесь мы используем:

* [.property]`x` – задает координату на оси X, где будет расположен ссылочный объект,
* [.property]`y` – задает координату на оси Y, где будет расположен ссылочный объект,
* [.property]`xlink:href` – URI ссылка на объект, реализованная с использованием идентификатора,
* [.property]`onclick` – запускает скрипт при нажатии на графический объект, который будет _plus_ или _minus_.     Скрипт раскрывает или скрывает поддерево графических символов (блоков).


==== <g>
footnote:[http://www.w3.org/TR/SVG11/struct.html#Groups]

Представляет собой контейнер для группировки связанных графических элементов.
Мы будем использовать его для ассоциации SVG элементов формирующих конкретный графический символ компонента схемы (блок).

* Атрибут [.property]`transform` – определяет графическое преобразование контента.
Графика может быть перемещена, масштабирована, повернута и искривлена.
Мы будем перемещать секции только на _x_ единиц по оси X и на _y_ единиц по оси Y, используя
[.property]`transform` = `translate`([.parameter]`x`, [.parameter]`y`).


==== <text>
footnote:[http://www.w3.org/TR/SVG11/text.html#TextElement]

Определяет текстовый графический элемент.
Он отображается с использованием тех же методов, что и другие графические элементы.
Будет использоваться для отображения различных имен, свойств и меток в блоках.
Будут необходимы атрибуты:

* [.property]`x` – представляет абсолютную позицию текста, отсчитанную от первого символа, по оси X.
    Также можно указать несколько (_n_) значений, которые затем представляют позиции первых _n_ символов.

* [.property]`y` – представляет абсолютную позицию текста, отсчитанную от первого символа на оси Y.
    Вы также можете указать здесь несколько значений, разделенные пробелом или запятой,
    с тем же значением, что и атрибут [.property]`x`.

* [.property]`visibility` – определяет, является ли текст видимым, скрытым
    или наследует видимость от своего родителя.
    Этот атрибут будет необходим, чтобы скрыть и показать некоторые символьные метки для компонентов схемы.


==== <line>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#LineElement]

Определяет отрезок.
С помощью линий и кривых соединяются отдельные графические символы (секции),
а из отрезков будут состоять и другие элементы.
Будем использовать атрибуты:

* [.property]`x1` – координаты начала линии на оси X,
* [.property]`y1` – координаты начала линии на оси Y,
* [.property]`x2` – координаты конца линии на оси X,
* [.property]`y2` – координаты конца линии на оси Y.


==== <polyline>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolylineElement]

Он определяет набор взаимосвязанных линий, обычно образующих открытые фигуры.
Элемент `<polyline>` используется только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат X и Y, начала и конца отрезков, из которых состоит это образование.


==== <polygon>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#PolygonElement]

Определяет замкнутую форму, состоящую из множества взаимосвязанных отрезков.
Элемент `polygon` будет использоваться только в некоторых графических символах компонентов схемы.

* Атрибут [.property]`points` – список пар координат по осям X и Y, образующих многоугольник.


==== <rect>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#RectElement]

Определяет прямоугольник.
Используется для рендеринга секций, их теней и других графических элементов.
Для классификации мы будем использовать атрибут [.property]`class`, следующим образом:

* [.property]`x` – координаты стороны прямоугольника по оси X, эта сторона,
    чьи координаты имеют меньшее значение в системе координат пользователя (обычно слева).
* [.property]`y` – координаты стороны прямоугольника вдоль оси Y
    сторона определяется по аналогии с атрибутом [.property]`x`, обычно это верхняя сторона.
* [.property]`width` – ширина прямоугольника,
* [.property]`height` – высота прямоугольника,
* [.property]`rx` – радиус эллипса, образующий закруглённые углы прямоугольника, по оси X.
* [.property]`onclick` – имеет то же значение, что и элемент `<use>`,
    атрибут будет установлен для прямоугольных кнопок управления.


==== <circle>
footnote:[http://www.w3.org/TR/SVG11/shapes.html#CircleElement]

Определяет окружность, круг. Он будет использоваться в выходных данных приложения только в качестве дополнительного графического элемента.
Будем использовать атрибуты:

* [.property]`cx` – координаты центра круга по оси X,
* [.property]`cy` – координаты центра круга по оси Y,
* [.property]`r` – радиус.


==== <path>
footnote:[http://www.w3.org/TR/SVG11/paths.html#PathElement]

Представляет контур формы.
Он может быть заполнен, обведен или может служить в качестве шаблона, по которому будут обрезаны другие объекты.
В этом приложении он будет служить конечной частью соединения секций.

* Атрибут [.property]`d` – определяет формы контура.
    Обычно состоит из команд _moveto_, _lineto_, _curveto_, _arc_ и _closepath_,
    или абсолютный или относительный.
        footnote:[Перемещение курсора в указанную позицию без рисования линии; с отрисовкой линии;
        с прорисовкой более детальной кривой; с рендерингом дуги;
        с прорисовкой отрезка, ведущей к начальной точке, чтобы сформировать замкнутую форму.]
    Для команд дополнительно вводятся пары координат по осям X и Y.


=== ECMAScript

ECMAScript это скриптовый язык, стандартизированный организацией _Ecma International_ в спецификации _ECMA-262_.
    footnote:[Ecma International: Standard ECMA-262. ECMAScript Language Specification 3rd edition (December 1999).
    http://www.ecma-international.org/publications/standards/Ecma-262.htm]
Широко используется в интернете, и, как правило, часто упоминается как _JavaScript_ или _JScript_, согласно основных диалектов этого языка.
Синтаксис намеренно похож на синтаксис _Java_, но он более облегчён,
чтобы сделать его более легким в использовании, например, нет необходимости объявлять тип переменных.
В то же время такой подход увеличивает вероятность ошибки.

ECMAScript это объектно-ориентированный язык программирования для выполнения вычислений и манипулирования объектами _в пользовательском окружении_.
Следовательно, он не работает независимо, ввод и вывод данных и обрабатываемых объектов предоставляет другая существующая система,
возможности которой расширяются скриптами.
Это суть скриптовых языков. _В этом приложении скрипт будет использоваться для обеспечения интерактивности модели схемы SVG в среде браузера._
Более подробная информация находится в разделе <<INTERACTIVITY>>.

ECMAScript был первоначально разработан для Интернета, чтобы оживить веб-страницы и перенести часть производительности на клиента - браузер - в архитектуре клиент-сервер.
Когда страница HTML (_HyperText Markup Language_) браузер предоставляет объекты, представляющие окна, меню, диалоговые поля, текстовые области, ссылки, кадры и многое другое.
Он также будет предоставлять способы запуска кода сценариев для таких событий, как загрузка страниц, изменение размеров окон, движение мыши, клики.

Однако нам нужны не специальные HTML-элементы, а интерфейсы к SVG или вообще объектам XML.
Общий интерфейс стандартизирован в следующей спецификации W3C, называемой DOM (_Document Object Model_).
    footnote:[W3C: Модель объекта документа (DOM). http://www.w3.org/DOM/]
DOM существует в нескольких уровнях – уровне 1-3. В этом приложении, второго уровня будет достаточно.
Для программных манипуляций с масштабируемыми графическими объектами создан специальный SVG DOM.
Это часть спецификации SVG
    footnote:[Приложение B: Модель объекта документа SVG (DOM). http://www.w3.org/TR/SVG/svgdom.html]
и далее расширяет DOM Уровень 2.
Мы могли бы использовать SVG DOM хорошо, но мы должны иметь дело с несовместимостью некоторых браузеров.
В итоге, мы будем придерживаться базового уровнем DOM 2, который является более распространенным.
Нам понадобятся методы и атрибуты, описанные в <<DOM1>> и <<DOM2>>, а их конкретное применение показано в примере <<EXAMPLES-SVG-XML>>:

* [.interface]#Document#
    :
        [.interface]#Element#
        [.method]`getElementById`
    (in
        [.interface]#DOMString#
        [.parameter]`elementId`
    ); получить элемент по его идентификатору, который указан в
        [.property]`id`
    .

* [.interface]#Document#
    :
        [.interface]#NodeList#
        [.method]`getElementsByTagName`
    (in
        [.interface]#DOMString#
        [.parameter]`tagname`
    ); получить список узлов с указанным именем тега.

* [.interface]#Node#
    :
        `readonly attribute`
        [.interface]#NodeList#
        [.property]`childNodes`
    ; содержит список всех детях узла.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    ); для получения значения атрибута с указанным именем.

* [.interface]#Element#
    :
        `void` [.method]`setAttribute`
    (in
        [.interface]#DOMString#
        [.parameter]`name`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем или создать новый атрибут для этого узла с
    с указанным именем и значением.

* [.interface]#Element#
    :
        [.interface]#DOMString#
        [.method]`getAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`localName`
    );чтобы получить значение атрибута с данным локальным именем и пространством имен.

* [.interface]#Element#
    :
        `void` [.method]`setAttributeNS`
    (in
        [.interface]#DOMString#
        [.parameter]`namespaceURI`
    , in
        [.interface]#DOMString#
        [.parameter]`qualifiedName`
    , in
        [.interface]#DOMString#
        [.parameter]`value`
    );
    установить значение атрибута с данным именем и в пространстве имен, или создать
    новый атрибут для этого узла с указанным именем и значением в данном пространстве имен.


=== CSS

CSS, _Cascading Style Sheets_, каскадные стили снова являются результатом активности W3C.
    footnote:[W3C: Cascading Style Sheets. Домашняя страница. http://www.w3.org/Style/CSS/]
Спецификация определяет язык описания стиля, который позволяет создателям и пользователям прикрепить стиль
(например, шрифты и отступы) к структурированным документам, таким как HTML документы и XML документы.
Это может отделить описание внешнего вида документа от его содержания и упростить создание и управление сайтом.

CSS предназначен быть легко читаемым для людей, стиль выражается в терминологии, которая является общей в DTP.
    footnote:[Desktop publishing (DTP), https://en.wikipedia.org/wiki/Desktop_publishing]
Одной из основных особенностей является то, что стиль является _каскадным_.
Это означает, что несколько определений стилей могут накладываться друг на друга, но применяется только последний.
Создатель прикрепляет предпочтительный стиль к документу, но пользователь может наложить на него свой собственный стиль,
с учетом человеческого или технологического преимущества <<CSS>>.

Стиль состоит из индивидуальных _правил_.
Каждое правило определяет внешний вид одного или нескольких элементов – элементов, выбранных _селектором_, первой части правила.
За селекторами следует список деклараций, оговоренных скобками, каждая декларация разделена запятой.
Каждая декларация состоит из _свойства_ (вслед за двоеточием) и _значения_ свойства.
Селектор может выбрать все элементы с определенным именем или элементами, содержащими указанные атрибуты,
он может указывать их в зависимости от того, где они размещены по отношению к другим элементам, и выбрать их в соответствии с
_псевдоклассами_ (`:hover`) и _псевдоэлементами_ (`:first-line`).
Если несколько правил могут быть применены к определенному элементу, он будет использоваться с более высоким приоритетом.
Проще говоря, это правило с более конкретным селектором.

_Каскадный стиль, который мы используем для вывода SVG этого приложения, позволит легко выполнять дополнительные манипуляции внешним видом
каждого класса графических элементов_, для более подробной информации см <<STYLE>>.

=== Java

Java — это объектно-ориентированный язык программирования для общего пользования.
Он был разработан _Sun Microsystems_ и стал одним из наиболее широко используемых языков программирования после его введения в 1995 году.
С мая 2007 года Java была разработана как открытый исходный код.

Характерной особенностью является переносимость на разные платформы.
Однажды написанная программа может работать на любой поддерживаемой операционной системе и оборудовании.
Письменный исходный код предварительно компилируется в так называемый _bytecode_, который является одинаковым для всех платформ;
различаются только виртуальные машины (_Virtual Machine_). Эти байткоды интерпретируют или переводят во время выполнения в нативный код.
Вы можете запустить программу везде, где есть соответствующая среда исполнения (_Java Runtime Environment_).

Намерение создателей Java в соответствии с <<M254>> вопросом заключается в том, чтобы создать язык, который будет:

* _Простой_: Java основывается на нескольких основных концепциях, которые разработчики могут легко узнать.

* _Подобный установленным технологиям_: синтаксис основан на синтаксисе популярного языка С++, но его сложность снижается.

* _Объектно-ориентированный_: программы работают с объектами. Определяются объекты класса, которые могут быть унаследованы от других классов.
    может реализовать готовые интерфейсы. Объекты или целые классы предоставляют свойства (атрибуты) и методы.
    Методы могут быть перекрыты и перегружены. Реализация скрыта;
    объекты предоставляют общедоступный интерфейс, который позволяет ими манипулировать, в противном случае они инкапсулируются. Язык сильно набран.

* _Надежный_: Java-программы строго проверяются перед запуском,
    язык не включает в себя различные опции C и C++, которые подвержены ошибкам.

* _Безопасный_: Java включает в себя специальные средства безопасности,
    программы, работающие по сети, не могут повредить файлы на компьютере или содержать вирусы.

* _Пореносимый_: Программы могут быть легко перенести с одной платформы на другую, с минимальными изменениями или без изменений.

* _Высокопроизводительный_: Java-программы работают достаточно быстро для желаемых целей.

* _Исполняемый_: связано с переносимостью, см.

* _Использование программных потоков_: это позволит программе выполнять сразу несколько задач для повышения производительности.

* _Динамичный_: Программы могут адаптироваться к изменениям в среде даже во время выполнения.

_Java я выбрал для этого приложения в основном из-за переносимости и большого распространения, этот язык также близок мне благодаря
курсам, завершенным в ВШЭ._

== Параметры загрузки и интерпретации модели XML Schema

В предыдущей главе я кратко описал технологии, используемые в интерактивном приложении визуализации.
Теперь вам нужно решить, как открыть схему, загрузить ее в память, интерпретировать и обработать.
Схему XML можно рассматривать с нескольких уровней:

[float]
=== Обычный текстовый файл

Если бы мы понимали схему только как текстовый файл, нам пришлось бы запрограммировать полный способ интерпретации разметки,
затем работать с результатом в виде документа XML. К счастью, это уже давно решается с помощью стандартизированных интерфейсов
SAX (_Simple API for XML_) и DOM (_Document Object Model_).

[float]
=== Документ XML

Было бы достаточно загрузить документ с помощью SAX и при этом искать типичные структуры, состоящие в основном из имен элементов и
значения атрибутов, важные для интерпретации схемы.
Эти структуры будут представлены в качестве объектов и их свойств, 
либо так, чтобы эти объекты соответствовали своему назначению - мы просто хотим визуализировать схему -,
либо в соответствии с спецификацией.
Соответствие спецификациям обеспечивает совместимость, функциональность и облегчает работу в случае изменений.
Однако после прочтения файла необходимо решить другие задачи, в том числе:

* Извлечение импортнных, встроенных и переопределенных схем, чтобы убедиться, что они не зациклились.
* Вставка типов, встроенных в спецификацию как часть схемы.
* Необходимо переопределить типы данных, группы элементов и группы атрибутов.
* Необходимо составить ссылки на глобально объявленные типы, первичные и уникальные ключи, 
    глобально объявленные элементы и атрибуты, глобально объявленные группы элементов и атрибутов.

Однако даже в этой области есть готовые реализации, которые просто указывают входной файл, устанавливают их с несколькими параметрами и позволяют загружать схему.
Мы обязательно воспользуемся одним из них (см. <<XSD-API>>), это сэкономит много работы.
В конце концов, мы будем работать на самом высоком уровне, с абстрактной моделью данных.

[float]
=== Абстрактная модель данных

Интерпретация схемы в соответствии с <<XSD1>> дает нам легкий доступ ко всем компонентам и свойствам.
С более подробным описанием обработки можно ознакомиться в главе <<XSD-PROCESSING>>.

[[XSD-API]]
=== Выбор соответствующей реализации схемы XML

Лучшим вариантом будет найти приемлемую реализацию с открытым исходным кодом, соответствующую спецификациям, и узнать, как с ней справиться.
Ниже приводится описание четырех известных открытых приложений, которые работают со схемой, и выбор одного из них.

==== Eclipse: Инструменты разработки моделей - XSD
footnote:[Eclipse Modeling: Model Development Tools(MDT). http://www.eclipse.org/modeling/mdt/?project=xsd#xsd]

_Model Development Tools_ (MDT) является частью _Eclipse_,
которая ориентирована на разработку и продвижение технологий для разработки моделей - Eclipse Modeling Project.
Eclipse предоставляет различные рамки, инструменты и реализации технологических стандартов.
В частности, MDT предназначен для внедрения стандартных метамоделей и образцов инструментов для разработки моделей на основе этих метамоделей.
Компоненты MDT:

* Бизнес-модель и нотация бизнес-процессов (BPMN2),
* Онтологическое определение метамодели (EODM),
* Метамодель управления информацией (IMM),
* Язык ограничения объектов (OCL)
* Семантика бизнес-вокабулярности и бизнес-правил (SBVR),
* Единый язык моделирования (UML2),
* Инструменты UML2,
* Модель XML Schema Infoset (XSD).

_XML Schema Infoset Model_ — это библиотека, предоставляющая интерфейс для приложений, которые ищут,
w3c xml схемы. Для управления компонентами можно использовать интерфейс, описанный в спецификации,
но вы также можете работать с представлением DOM схемы. Для модификаций оба представления меняются соответственно.
Библиотека также включает в себя услуги по сериализации и десериализации схем. _Цель проекта должна полностью охватить функциональность
представления XML схем_, но без предоставления службы валидации, которая обычно входит в валидаторы парсеров (Xerces-J).

==== Apache: Xerces2 Java Parser - XML Schema
footnote:[The Apache XML Project: Xerces2 Java ParserReadme. http://xerces.apache.org/xerces2-j/]

_Xerces2_ является открытым XML парсером с исходным кодом, разработанным компанией _Apache_, его преимуществом является высокая производительность и соответствие стандартам.
Кроме того, он включает в себя Xerces Native Interface, framework для построения компонентов и парсеров конфигураций.

Xerces может сравнивать документы, написанные в соответствии с нотациями XML 1.1, а также правильно работает с пространствами имен
в соответствии с XML Namespaces 1.1. Он также обеспечивает полную реализацию DOM Level 3 Core,
Load and Save реализует XML Inclusions (они являются нотациями W3C) и обеспечивает поддержку каталогов OASIS XML v1.1.

_Xerces2 также является процессором схемы XML, который, за некоторыми незначительными исключениями, полностью соответствует спецификации <<XSD1>> и <<XSD2>>_.

==== Saxonica: Saxon
footnote:[Saxon, The XSLT andXQuery Processor.http://saxon.sourceforge.net]

_Saxon_ – это полная реализация рекомендаций XSLT 2.0, XQuery 1.0 и консорциума XPath 2.0 w3c.
Публикуется _Saxonica_, а также для платформ Java и .NET.
Он выпущен в двух версиях: Saxon-B является продуктом с открытым исходным кодом, реализует XSLT 2.0 и XQuery так, что
что он соответствует спецификациям только на базовом уровне требований.
Saxon-SA является коммерческим продуктом, но он позволяет применять XSLT и XQuery с использованием схем.
Таким образом, можно импортировать схему и проверять входные или выходные данные и выбирать элементы в соответствии с их типом.
Saxon-SA также включает в себя отдельный валидатор схемы XML и другие расширения по сравнению с Saxon-B.

_К сожалению, в версии с открытым исходным кодом нет интерфейса для доступа к компонентам схемы xml, и поэтому мы не можем использовать Saxon.

==== ExoLab: Castor - Source Generator XML Schema Support
footnote:[The Castor Project.http://www.castor.org/xmlschema.html]

_Castor_ — это платформа с открытым исходным кодом для Java, используемая для связывания данных, преобразования данных между объектами Java, XML-документами и таблицами из реляционных баз данных.

Она включает в себя, среди прочего, генератор исходного кода XML.
Последний создает классы Java, представляющие объектную модель в соответствии с входной XML-схемой.
Поэтому Castor поддерживает спецификацию W3C XML Schema <<XSD1>>, спецификацию <<XSD2>>.
Модель объекта представляет схему XML в памяти компьютера, в то время как генератор исходного кода преобразует данные
типов и структур схемы в соответствующие типы и структуры Java.
_Объектные модели схемы могут читать и записывать документы, манипулировать ими.
Они соответствуют спецификациям без отступлений._ Генератор кода еще не предлагает отображения для всех компонентов.

==== Volba Xerces2

Из описанных реализаций мы не можем использовать Saxon, другие кажутся эквивалентными и полностью соответствуют спецификации.
Наконец, я выбрал процессор схемы XML, который является частью парсера _Xerces2-J_.
Он прост и предоставляет именно те варианты, которые нам понадобятся.
Классы, представляющие отдельные компоненты, содержат методы доступа к свойствам, определеным в спецификации.
Изменение свойства не поддерживается, и в любом случае мы не будем его использовать.
Кроме того, легко управлять процессором, загружать схему и обрабатывать ее, использование хорошо документировано.
Кроме того, Xerces используется для визуализации схем в известном редакторе XML oXygen.
Eclipse MDT и Castor будут служить так же хорошо, но их функциональность излишне широка (работа с деревом DOM, создание и изменение схем).

== Дизайн графической модели

Прежде чем начать программировать приложение, которое будет генерировать графическое представление схем XML,
Я должен показать, как должно выглядеть это представление.
Я собираюсь принять решение о правильном типе модели, разработать дизайн символов - элементов модели - и связать их,
Я буду иметь дело с интерактивностью итоговой модели. Все это является предметом этой главы.

=== Два типа моделей

Существует два основных способа отображения схемы XML.
Оба, конечно, основаны на дереве документов XML, но отличаются по своей детализации и предназначению для использования.
Я покажу разницу на выходе _oXygen_,
    footnote:[Oxygen XML editor, официальная страница. http://www.oxygenxml.com]
который предлагает оба типа отображения.

В качестве примера используется простая схема XML:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>

    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

==== Полная модель

Полная графическая модель копирует XML-представление схемы. Для каждого элемента отображается собственный символ.
Кроме того, можно открыть дерево символов дальше и увидеть, что скрыто за ссылками на глобально определенные компоненты
схемы, такие как определения типов, глобальные декларации элементов, их группы и т.д.

Например, см <<FULL-MODEL>>.
После символа элемента `contact`, я раскрыл ветку с определением ее типа `ContactType`.
Это последовательность элементов `phone` и `address`.
Открыв дерево снова, я хотел бы получить определение типов этих элементов.
Кроме того, я могу видеть их ниже, как потомков декларирование `ContactType`.

Полная модель очень подробная.
Он предлагает компоненты, которые могут быть использованы для расширения схемы, но еще не применены в описанном документе;
подробно отображает все параметры и значения, глобальные определения типов, групповые декларации; списки импортированных и встроенных файлов.
Поэтому он предназначен для создателей схем XML, а не пользователей.

[[FULL-MODEL]]
.Представление схемы в полной модели
image::images/model_full.png[]


==== Логическая модель

В отличие от этого, логическая графическая модель отображает только основную информацию, важную для создателей документов XML, которые соответствуют схемам.
Символы значительно меньше, чем в случае полной модели.
Речь идет о показе пользователю возможной структуры элементов и атрибутов.
Ссылки на глобальные компоненты должны быть составлены так же, как и для полной модели,
однако при просмотре дерева на первый взгляд не видно, в какой части схемы определяется элемент.

Например, см. рисунок <<LOGICAL-MODEL>>.
Корневым элементом валидного документа XML является `contact`.
Внутри него должна появиться последовательность элементов `phone` и `address`.
В то время как `телефон` содержит строку текста (_string_), внутри элемента `address` есть другая последовательность,
и это элементы `name`, `street` и `city`.
Каждый из них имеет тип текстовой строки.

Таким образом, логическая модель подходит для пользователей схем XML, что облегчает им понимание определенных структур;
создатели также позволят быстрее контролировать свою работу.
Именно логическая модель будет результатом работы моего приложения, поскольку цель состоит в том, чтобы создать документацию схемы,
которая будет интуитивно понятна, и каждый быстро разберется в ней.
В документации описывается не схема XML, а документы, совместимые со схемой XML;
в частности, структуры (комбинирование, наследование) элементов, их атрибутов и типов данных.
Элементы схемы, которые не являются необходимыми для понимания цели, будут удалены из модели, как и компоненты, которые не используются напрямую.

[[LOGICAL-MODEL]]
 Представление диаграммы по логической модели
image::images/model_logical.png[]


=== Модель как дерево абстрактных символов

Эти примеры и характер документов XML подразумевают, что символы, которые составляют графическую модель,
понимается как узлы дерева.
Таким образом, на базовом уровне, будет абстрактный символ ([.class]`AbstractSymbol`)
со ссылкой на вашего родителя и отсортированный список ссылок на своих детей.
[.class]`AbstractSymbol` предоставит методы получения и назначения этих ссылок и запросов для получения дополнительной информации.

Кроме того, для визуализации каждого символа необходимо знать горизонтальную ([.parameter]`xPosition`)
и вертикальную позиции ([.parameter]`yPosition`), каждый символ имеет ширину и высоту.
[.class]`AbstractSymbol` определяет методы настройки подходящей ширины, высоты и визуализации символа.
Они должны быть переопределены у определенных символов.

[[ABSTRACT-MODEL]]
.Модель абстрактного символа
image::images/abstract_symbols.png[]


=== Символы отдельных компонентов схемы

Конкретный символ расширяет свойства абстрактного символа ([.class]`AbstractSymbol`).
Он в обязательном порядке заменяет методы для установки правильной ширины и высоты и для визуализации символа.
Ширина должна быть установлена с учетом длины текстовых строк, чтобы вписаться в символ.
При использовании пропорциональных шрифтов это можно решить только приблизительно.

Символ также предоставляет методы получения и задания параметров, описанных ниже.
Если нет ни одного из перечисленных параметров (например, потому что он представляет собой дополнительное свойство), то его значение не указано или обработано иным образом.

Ниже приведен обзор конкретных символов и их связей со схемой XML.
В описаниях параметров я исхожу из свойств и значений, определенных в спецификации <<XSD1>>.

[[SYMBOL-SCHEMA]]
==== `schema`

[.class]`SymbolSchema` представляет собой корневой элемент схемы.

Для рендеринга не нужно указывать никаких параметров.

.Символ `schema`
image::symbols/schema.svg[]


[[SYMBOL-ELEMENT]]
==== `element`

[.class]`SymbolElement` отображает название элементов информации элемента, их тип и классификацию,
пространство имен и другие свойства, доступные из компонента объявления элемента  (_Element declaration_).

* Параметр [.parameter]`name`- это текстовая строка, содержащая локальную часть информации об элементе, имена элементов,
    которые подтверждены. Значение задается объявлением элемента в свойстве [.property]`name`.

* Параметр [.parameter]`namespace`- это строка с пространством имен. Он квалифицирует информационный элемент элемента.
    Целевое пространство имен указывает на объявление элемента в свойстве [.property]`namespace`.

* Параметр [.parameter]`type` - это шрифт, содержащий имя типа элемента информационного элемента,
    pokud je tento typ pojmenovaný; nebo, pokud je typ anonymní a zároveň jednoduchý, obsahuje jméno základního typu,
    ze kterého je typ informačních položek element odvozen.
    Základem je vlastnost [.property]`name` definice typu (_Type definition_).

* Параметр [.parameter]`cardinality`- это строка, указывающая минимальное и максимальное количество вхождений элемента information items.
    Если он не указан в списке, это означает, что значения неявны (min = max = 1), и строка не будет визуализирована.
    Минимальное и максимальное число вхождений определяется свойствами частицы (_Particle_), содержащей это объявление элемента.
    Их имена [.property]`min occurs` a [.property]`max occurs`.

* Параметр [.parameter]`nillable`- логический тип говорящий, может ли он иметь информационные позиции элемента
    пустое содержимое (значение `true`) или нет (`false`).
    Значение указывается объявлением элемента в свойстве [.property]`nillable`.

* Параметр [.parameter]`abstr` является логическим типом.
    Если значение установлено на `true`, то это объявление само по себе не используется для проверки содержимого элементов.
    Значение указывается объявлением элемента в свойстве [.property]`abstract`.

* Параметр [.parameter]`substitution`- это строка с именем группы подстановок, к которой принадлежит данное объявление.
    Фактическое значение обеспечивается объявлением элемента в свойстве [.property]`substitution group affiliation`.

Нужно будет втиснуть в символ много информации, при этом не заполняя большую площадь.
Поэтому последние три свойства будут отображаться только при нажатии мыши вместо свойств [.property]`namespace` и [.property]`type`.

.Символ `element` (нормальный режим; при движении)
image::symbols/element.svg[]


[[SYMBOL-ATTRIBUTE]]
==== `attribute`

[.class]`SymbolAttribute` отображает имя элемента атрибутивной информации,
его вид и классификацию в пространстве имен и другие свойства, доступные из компонентов использования атрибутов (_Attribute use_)
и объявление атрибута (_Attribute declaration_).

* Параметр [.parameter]`name`- это текстовое сообщение, содержащее локальное сообщение, указывающее на элемент атрибутивной информации,
    что подтверждается. Значение предоставляется объявлением атрибута в свойстве [.property]`name`.

* Параметр [.parameter]`namespace` - это строка с пространством имен.
    Он квалифицирует атрибут информационного элемента. Целевое пространство имен указывает объявление атрибута своими свойствами [.property]`namespace`.

* Параметр [.parameter]`type` - это строка, содержащая имя атрибута типа информационного элемента,
    если этот тип имеет имя; или если тип является анонимным, содержит имя базового типа,
    из которого выводится тип атрибута информационного элемента. Основой является свойство [.property]`name` определение простого типа (_Simple type definition_).

* Параметр [.parameter]`required` - логический тип говорящий, должен ли присутствовать
    соответствующий элемент атрибутивной информации (значение `true`), или же это необязательно (`false`).
    В дополнение к перечислению соответствующей строки необязательный атрибут будет ограничен пунктирной линией,
    в то время как обязательный атрибут будет полным. Параметр имеет то же значение, что и свойство использования атрибута с именем [.property]`required`.

* Параметр [.parameter]`constraint` - это текстовая строка, указывающая ограничение на значение
     элемента атрибутивной информации (фиксированное или стандартное значение). Строка создается из свойства [.property]`value constraint`.
    Это то, что обеспечивает компонент использования атрибута или объявление атрибута.

Значения последних двух параметров отображаются только после наведения курсора мыши на символ `attribute`.

.Символ `attribute` (необязательный атрибут в обычном режиме; и при наведении курсора мыши; обязательный атрибут в обычном режиме)
image::symbols/attribute_optional.svg[]


[[SYMBOL-ANY]]
==== `any`

[.class]`SymbolAny` představuje divokou kartu (_Wildcard_) pro elementy.
Na jejím místě mohou být informační položky element s libovolným lokálním jménem, které ale musí vyhovět omezením kladeným na jejich jmenný prostor.

* Parametr [.parameter]`namespace` je textový řetězec, představující omezení kladené na jmenný prostor informačních položek element.
    Řetězec je utvořen z vlastnosti [.property]`namespace constraint` komponenty divoká karta.

* Parametr [.parameter]`processContents` je celé číslo, které slouží k rozlišení způsobů zpracování informačních položek element.
    Hodnota vychází z vlastnosti [.property]`process contents` divoké karty a závisí na ní vyobrazení symbolu. Parametr nabývá hodnot:

** [.constant]`3` – způsob zpracování `lax`. Pokud existuje unikátní deklarace položky, musí položka této deklaraci vyhovovat.
** [.constant]`2` – odpovídá způsobu zpracování `skip`. Nevzniká žádné omezení, položka musí být pouze dobře strukturované XML.
** [.constant]`1` (a ostatní přípustné hodnoty) – způsob zpracování `strict`.
    Informační položka musí mít přiřazen xsi:type, nebo musí být k dispozici její deklarace, oproti které je prováděna validace.

* Parametr [.parameter]`cardinality` je řetězec, který udává minimální a maximální počet výskytů informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1),
    a řetězec nebude vykreslen. Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_)
    obsahující tuto divokou kartu. Jejich názvy jsou [.property]`min occurs` a [.property]`max occurs`.


.Symbol `any` (způsob zpracování `strict`; způsob zpracování `skip`; způsob zpracování `lax`)
image::symbols/any_strict.svg[]


[[SYMBOL-ANY-ATTRIBUTE]]
==== `anyAttribute`

[.class]`SymbolAnyAttribute` představuje divokou kartu (_Wildcard_) pro atributy.
Na jejím místě mohou být informační položky atribut s libovolným lokálním jménem, které ale musí vyhovět omezením kladeným na jejich jmenný prostor.

* Parametr [.parameter]`namespace` je textový řetězec, představující omezení kladené na jmenný prostor informačních položek atribut.
    Řetězec je utvořen z vlastnosti [.property]`namespace constraint` komponenty divoká karta.

* Parametr [.parameter]`processContents` je celé číslo, které slouží k rozlišení způsobů zpracování informačních položek atribut.
    Hodnota vychází z vlastnosti [.property]`process contents` divoké karty a závisí na ní vyobrazení symbolu. Parametr nabývá hodnot:

** [.constant]`3` – způsob zpracování `lax`. Pokud existuje unikátní deklarace položky, musí položka této deklaraci odpovídat.
** [.constant]`2` – odpovídá způsobu zpracování `skip`. Nevzniká žádné omezení, položka musí být pouze dobře strukturované XML.
** [.constant]`1` (a ostatní přípustné hodnoty) – způsob zpracování `strict`.
    Informační položka musí mít přiřazen xsi:type, nebo musí být k dispozici její deklarace, oproti které je prováděna validace.


.Symbol `anyAttribute` (způsob zpracování `strict`; způsob zpracování `skip`; způsob zpracování `lax`)
image::symbols/any_attribute_strict.svg[]


[[SYMBOL-ALL]]
==== `all`

[.class]`SymbolAll` znázorňuje kompozitor `all` modelové skupiny (_Model group_).
Ten říká, že se děti informační položky element, definované v modelové skupině jako [.property]`particles`, mohou vyskytovat v libovolném pořadí.

* Parametr [.parameter]`cardinality` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
Jejich názvy jsou [.property]`min occurs` a [.property]`max occurs`.


.Symbol `all`
image::symbols/all.svg[]


[[SYMBOL-CHOICE]]
==== `choice`

[.class]`SymbolChoice` znázorňuje kompozitor `choice` modelové skupiny (_Model group_).
Pouze jedna z částic (_Particle_), definovaných v modelové skupině jako [.property]`particles`,
se může v XML dokumentu objevit jako dítě informační položky element.

* Parametr [.parameter]`cardinality` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
    Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
    Jejich názvy jsou [.property]`min occurs` a [.property]`max occurs`.


.Symbol `choice`
image::symbols/choice.svg[]


[[SYMBOL-SEQUENCE]]
==== `sequence`

[.class]`SymbolSequence` znázorňuje kompozitor `sequence` modelové skupiny (_Model group_).
Každá z částic (_Particle_), definovaných v modelové skupině jako [.property]`particles`,
se může objevit v XML dokumentu jako dítě informační položky element, a to ve specifikovaném pořadí.

* Parametr [.parameter]`cardinality` je řetězec, který udává minimální a maximální počet výskytů dětí informační položky element.
    Pokud není uveden, znamená to, že hodnoty jsou implicitní (min = max = 1), a řetězec nebude vykreslen.
    Minimální a maximální počet výskytů je dán vlastnostmi částice (_Particle_) obsahující tuto modelovou skupinu.
    Jejich názvy jsou [.property]`min occurs` a [.property]`max occurs`.


.Symbol `sequence`
image::symbols/sequence.svg[]


[[SYMBOL-UNIQUE]]
==== `unique`

[.class]`SymbolUnique` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie `unique`.
Ta zajišťuje jedinečnost hodnot v rámci obsahu vymezeného selektorem <<SYMBOL-SELECTOR>>,
které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>.

* Parametr [.parameter]`name` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]`name`.
* Parametr [.parameter]`namespace` je řetězec se jmenným prostorem.
    Ten kvalifikuje definici identitního omezení. Jmenný prostor udává definice svou vlastností [.property]`namespace`.
    Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.


.Symbol `unique`
image::symbols/unique.svg[]


[[SYMBOL-KEY]]
==== `key`

[.class]`SymbolKey` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie `key`.
Ta zajišťuje jedinečnost a přítomnost hodnot v rámci obsahu vymezeného selektorem <<SYMBOL-SELECTOR>>,
které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>.

* Parametr [.parameter]`name` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]`name`.
* Parametr [.parameter]`namespace` je řetězec se jmenným prostorem.
    Ten kvalifikuje definici identitního omezení. Jmenný prostor udává definice svou vlastností [.property]`namespace`.
    Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.


.Symbol `key`
image::symbols/key.svg[]


[[SYMBOL-KEYREF]]
==== `keyref`

[.class]`SymbolKeyref` znázorňuje část definice identitního omezení (_Identity-constraint definition_),
konkrétně jméno a jmenný prostor kategorie `keyref`.
Ta zajišťuje, že hodnoty, které jsou výsledkem vyhodnocení XPath výrazů uvedených v polích <<SYMBOL-FIELD>>,
budou odpovídat hodnotám, jež specifikuje vlastnost [.property]`referenced key` definice identitního omezení.
Tato podmínka se vyhodnocuje v rámci obsahu určeného selektorem <<SYMBOL-SELECTOR>>.

* Parametr [.parameter]`name` je textový řetězec, obsahující jméno definice identitního omezení.
    Hodnotu poskytne tato definice ve vlastnosti [.property]`name`.
* Parametr [.parameter]`namespace` je řetězec se jmenným prostorem. Ten kvalifikuje definici identitního omezení.
    Jmenný prostor udává definice svou vlastností [.property]`namespace`. Dvojice jméno a jmenný prostor identifikuje definici identitního omezení, a proto musí být v rámci XML schématu unikátní.
* Parametr [.parameter]`refer` je řetězec, který slouží jako odkaz na jinou definici identitního omezení
    kategorie `key` nebo `unique`. Hodnotu poskytne tato definice ve vlastnosti [.property]`referenced key`.


.Symbol `keyref`
image::symbols/keyref.svg[]


[[SYMBOL-SELECTOR]]
==== `selector`

[.class]`SymbolSelector` slouží ke zobrazení vlastnosti [.property]`selector` definice identitního omezení (_Identity-constraint definition_).

* Parametr [.parameter]`xpath` je textový řetězec. Specifikuje omezený XPath výraz, relativní k instanci deklarovaného elementu.
    Výraz musí identifikovat množinu uzlů – podřízených elementů, na které se vztahuje omezení.
    Hodnota parametru se získá z vlastnosti [.property]`selector` definice identitního omezení.


.Symbol `selector`
image::symbols/selector.svg[]


[[SYMBOL-FIELD]]
==== `field`

[.class]`SymbolField` slouží ke zobrazení jednoho prvku ze seznamu – vlastnosti [.property]`fields`
definice identitního omezení (_Identity-constraint definition_).

* Parametr [.parameter]`xpath` je textový řetězec. Specifikuje omezený XPath výraz, relativní ke každému elementu,
    který je vybrán selektorem <<SYMBOL-SELECTOR>>. Výraz musí identifikovat konkrétní uzel (element nebo atribut),
    jehož obsah nebo hodnota musí být jednoduchého typu a je použita v omezení. Hodnota parametru se získá z
    vlastnosti [.property]`fields` definice identitního omezení.


.Symbol `field`
image::symbols/field.svg[]


[[SYMBOL-LOOP]]
==== smyčka

[.class]`SymbolLoop` je pomocný symbol, který nepatří do XML schématu. Vykreslí se, pokud by mělo dojít k zacyklení.
Deklarace elementu totiž může nepřímo obsahovat samu sebe, a to za splnění těchto podmínek:

. Deklarace elementu je komplexního typu.
. Komplexní typ (1) obsahuje částici (_Particle_).
. Termínem ([.property]`term`) částice (2) je modelová skupina (_ModelGroup_) – vždy složená z dalších částic.
. Termínem alespoň jedné z částic (3) je deklarace elementu totožná s deklarací uvedenou v bodě (1);
    nebo je termínem alespoň jedné z částic (3) modelová skupina a v tom případě se postupuje rekurzivně od bodu (3),
    dokud nebude nalezena deklarace elementu totožná s deklarací uvedenou v bodě (1).

Nemá parametry.

.Symbol smyčky
image::symbols/_loop.svg[]


[[INTERACTIVITY]]
=== Interaktivita modelu

Jedním z požadavků kladených na grafický model je jeho interaktivita.
SVG se dá rozpohybovat pomocí ECMAScriptu (JavaScriptu). Jednoduše půjde zajistit změnu zobrazovaných informací při najetí kurzoru myši na symboly <<SYMBOL-ELEMENT>> a <<SYMBOL-ATTRIBUTE>>.
Složitější je implementovat rozbalování a skrývání podstromů jednotlivých symbolů.
Aby to bylo možné, musí SVG dokument znát umístění symbolů v rámci jejich stromu.
K vysvětlení použiji následující příklad:

[source, xml]
----
<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
    <rect class='shadow' x='3' y='3' width='117' height='46'/>
    <rect class='boxelement' x='0' y='0' width='117' height='46'
        onmouseover='makeVisible("_1_1_1_2")' onmouseout='makeHidden("_1_1_1_2")'/>
    <text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
    <text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
    <text class='strong' x='5' y='27'>address</text>
    <text class='visible' x='5' y='41'>type: AddressType</text>
    <line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
    <path class='connection' d='M-35,-40 Q-35,15 0,23'/>
    <use x='116' y='17' xlink:href='#plus' id='s_1_1_1_2' onclick='show("_1_1_1_2")'/>
</g>
----

Jedná se o XML reprezentaci symbolu `address`.
Ten se skládá z několika SVG elementů a je zobrazen jako <<ADDRESS-SYMBOL>>.

* Symbol je tvořen dvěma obdélníky. První je mírně posunutý a tvoří lehký stín.
    Druhý z nich tvoří hlavní box a je citlivý na najetí myši.
* Dále symbol obsahuje čtyři textové položky. První dvě s obsahem „nillable: 0"` a „abstract: 0"`
    jsou teď skryty. Řetězce „address"` a „type: AddressType"` jsou naopak viditelné.
* Následuje úsečka a na ní navazující křivka, která zleva připojuje symbol ke svému rodiči.
* Nakonec je použit předem definovaný symbol „plus"`, což je malý čtverec se znakem plus.
    Je citlivý na kliknutí myši.

Navíc, aby se se symbolem dalo pracovat jako s jedním celkem,
jsou všechny popsané položky obaleny jako skupina  elementem `<g>`
Ten dále umožňuje transformaci pozice symbolu a jeho jednoznačnou identifikaci v rámci stromu.

[[ADDRESS-SYMBOL]]
.Symbol elementu address (v normálním režimu; při najetímyši)
image::images/address.svg[]

Pro změnu zobrazovaných položek při najetí myši stačí, aby měl každý symbol jednoznačný identifikátor.
Ten je předáván ECMAScriptovým metodám [.method]`makeVisible`([.parameter]`id`)
a [.method]`makeHidden`([.parameter]`id`) při najetí kurzoru myši na hlavní box symbolu, respektive při jeho sjetí z boxu.
Změna spočívá v tom, že položky, které měly nastavenou třídu ([.property]`class`) na hidden, budou nyní viditelné.
Jedná se o textové řetězce „nillable: 0"` a „abstract: 0"`. Naopak položky ve třídě visible budou dočasně skryty.
Sem patří pouze řetězec „type: AddressType"`. Viz obrázek <<ADDRESS-SYMBOL>>.

Zde použitý identifikátor symbolu je poměrně složitý, jedná se o řetězec `_1_1_1_2`.
Jeho použití je však opodstatněné.
Už jsem napsal, že pro práci s podstromy symbolů, musí být v SVG dokumentu patrné, do které části stromu symbol spadá.
To lze jednoznačně určit pomocí takovýchto identifikátorů, uvedením cesty od kořene stromu až ke konkrétnímu symbolu.
Podívejte se na obrázek <<INTERACTIVITY_MODEL>>.

[[INTERACTIVITY_MODEL]]
.Model s kódy symbolů
image::images/model_interactivity.png[]

Kořenový symbol má identifikátor `_1`.
Potržítko je nutné kvůli přípustným hodnotám attributu `id`, je tedy zvoleno i jako oddělovač.
Kořenový symbol má dále dvě děti.
Jejich identifikátory jsou tvořeny identifikátorem rodiče a přidanou vlastní částí, která udává jejich pozici.
Dostáváme řetězce `_1_1` a `_1_2`.
Analogicky symbol `_1_1` má dítě `_1_1_1`.
Symbol s identifikátorem `_1_1_1` má dvě děti a druhé z nich (`_1_1_1_2`) je popisovaný prvek, symbol elementu `address`.

Při kliknutí na symbol minus za boxem `address` se zavolá ECMAScriptová metoda [.method]`show`([.parameter]`"_1_1_1_2"`).
Ta provede následující:

* Změní tu symbol minus na plus, přepsáním atributu `xlink:href` elementu `<use>`
    tak, aby odkazoval na předem definovaný grafický objekt `plus`.
* Schová celý podstrom symbolů připojený zprava k boxu. Patří do něj všechny symboly,
    jejichž identifikátor začíná také na `_1_1_1_2`. U elementů `<g>`
    obalujících objekty, z nichž se symbol skládá, se nastaví atribut `visibility` na hodnotu [.property]`hidden`.
* Vzniklý prostor se zaplní vedlejšími větvemi. Ty se posunou směrem nahoru, přenastavením hodnoty atributu `transform`
    u seskupujícícho elementu `<g>`.
    Výpočet vzdálenosti, o kterou se mohou symboly posunout, je nutné provést pouze pro jeden symbol, pro ostatní je vzdálenost stejná.
    Zde poslouží také systém identifikace.
    Navíc je třeba zkrátit úsečku propojující rodičovské symboly s posouvanou větví.

Výsledek je možné vidět na obrázku <<INTERACTIVITY-MODEL-2>>.
Pokud teď klikneme na symbol plus, zavolá se opět metoda [.method]`show`([.parameter]`"_1_1_1_2"`).
Ta teď ale bude pracovat přesně naopak, než bylo popsáno.

Kromě výše uvedené funkčnosti budou poskytnuta tlačítka pro zobrazení a skrytí všech symbolů, až na kořenový.
Časem přibudou i škálovací tlačítka _zoom in_ a _zoom out_, zatím se lze obejít bez nich a využít funkce prohlížeče.

[[INTERACTIVITY-MODEL-2]]
.Model po skrytí podstromu elementu address
image::images/model_interactivity2.png[]


=== Výsledná SVG reprezentace schématu

Když splním všechny podmínky, získám z aplikace výstup ve formátu SVG,
jehož grafickou reprezentaci si můžete prohlédnout na obrázku <<MY-MODEL>>.
V příloze <<EXAMPLES>> je pro přehlednost znovu uvedeno jak vstupní XML schéma,
tak i SVG výstup v XML i grafické reprezentaci.

[float]
[[STYLE]]
==== Styl

Výsledný diagram se ale dá ještě dodatečně upravovat, jeho vzhled je totiž nastaven v CSS stylu.
Aplikace dokáže styl generovat jako součást SVG dokumentu nebo zvlášť, nebo pouze připojit existující externí styl.
Kaskádové styly využívají selektory pro výběr určitých elementů, kterým pak nastaví vzhled.
Výběr může být určen názvem tagu, pokud však chceme jednotně upravit určité logické celky, lze využít jejich zařazení do tříd ([.property]`class`). V SVG výstupu vznikly tyto třídy:

* [.property]`strong` pro důležité nápisy jako jsou názvy elementů a atributů. Písmo je větší a tučné.
* [.property]`small` pro text, jenž je součástí grafiky, psaný menším písmem.
* [.property]`big` pro text, jenž je součástí grafiky, psaný větším písmem.
* [.property]`button` pro tlačítka; podstatou je, že má v parametru [.property]`pointer-events`
    zapnutou citlivost na určité události, především nám jde o kliknutí myši.
* [.property]`shadow` je třída pro stín zobrazovaný za některými boxy.
* [.property]`connection` zahrnuje úsečky a křivky propojující jednotlivé grafické symboly (boxy).
* [.property]`empty` pro tvary obtažené, bez výplně.
* [.property]`filled` pro tvary vyplněné, bez obtažení.
* [.property]`boxelement` pro box symbolu <<SYMBOL-ELEMENT>>.
* [.property]`boxattribute1` pro box symbolu <<SYMBOL-ATTRIBUTE>>, pokud je použití atributu povinné.
* [.property]`boxattribute2` pro box symbolu <<SYMBOL-ATTRIBUTE>>, pokud je použití atributu volitelné.
* [.property]`boxany` pro box symbolu <<SYMBOL-ANY>>.
* [.property]`boxanyattribute` pro box symbolu <<SYMBOL-ANY-ATTRIBUTE>>.
* [.property]`boxschema` pro box symbolu <<SYMBOL-SCHEMA>>.
* [.property]`boxcompositor` pro boxy symbolů <<SYMBOL-ALL>>, <<SYMBOL-CHOICE>>, <<SYMBOL-SEQUENCE>>.
* [.property]`boxloop` pro box symbolu <<SYMBOL-LOOP>>.
* [.property]`boxidc` pro boxy symbolů <<SYMBOL-UNIQUE>>, <<SYMBOL-KEY>>, <<SYMBOL-KEYREF>>.
* [.property]`boxselector` pro box symbolu <<SYMBOL-SELECTOR>>.
* [.property]`boxfield` pro box symbolu <<SYMBOL-FIELD>>.
* [.property]`lax` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _lax_.
* [.property]`skip` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _skip_.
* [.property]`strict` slouží k dalšímu nastavení vzhledu u boxů <<SYMBOL-ANY>> a <<SYMBOL-ANY-ATTRIBUTE>>,
    pokud je u nich způsob zpracování nastaven na _strict_.


[float]
==== Původní styl generovaný aplikací

[source, css]
----
svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}
----

[[MY-MODEL]]
.Výstup aplikace pro výše uvedený příklad XML schématu
image::images/model_my.svg[]


[[XSD-PROCESSING]]
== Zpracování XML schématu

V této kapitole ukážu způsob procházení mezi komponentami schématu a vytvořím tak koncept jádra aplikace.
Jednotlivé oddíly se věnují zpracování konkrétních komponent a vedle algoritmu zpracování obsahují také popis převzatý ze specifikace <<XSD1>>.
Odkaz na konkrétní část specifikace uvádím u každého oddílu v poznámce pod čarou.

Jako základní knihovnu, na které postavím aplikaci, jsem po předchozím uvážení zvolil open-source parser Xerces.
Ten poskytuje plnou podporu XML schémat podle <<XSD0>>, <<XSD1>> a <<XSD2>>, až na několik omezení,
které v naprosté většině případů nebudou tvořit překážku.
    footnote:[The Apache XML Project: Xerces2 Java Parser Readme. XML Schema. http://xerces.apache.org/xerces2-j/xml-schema.html]
Implementace Xerces tak bude pracovat v souladu se specifikací W3C a bude užívat její termíny.

Obrázek <<DIAGRAM_KOMPONENT>> nám umožní udělat si snadno představu o vazbách a základních vlastnostech jednotlivých
komponent XML schématu, jež jsou definovány v třetí části specifikace.
    footnote:[Schema Component Details. http://www.w3.org/TR/xmlschema-1/#components]

[[PROCESS-MODEL]]
=== Zpracování samotného schématu
footnote:[http://www.w3.org/TR/xmlschema-1/#Schemas]

Schéma (_Schema_, v Xercesu třída [.class]`XSModel`) slouží na abstraktní úrovni jako kontejner pro jednotlivé komponenty.
Jedná se o komponenty globální, tedy pojmenované a anotace.

Metoda [.method]`processModel`([.class]`XSModel`[.parameter]`model`) bude mít na starost zpracování schématu.

. Vytvoří se symbol <<SYMBOL-SCHEMA>> a bude vložen jako kořen do stromové struktury symbolů.
. Bude volána pomocná metoda [.method]`processElementDeclarations`([.parameter]`elementDeclarations`)
    [<<PROCESS-ELEMENT-DECLARATIONS>>], parametrem jsou všechny globálně deklarované elementy.

Ostatní vlastnosti schématu ([.property]`attribute declarations`, [.property]`model group definitions`,
    [.property]`attribute group definitions`, [.property]`type definitions`, [.property]`notation declarations`,
    [.property]`annotations`) pro tvorbu logického modelu grafické reprezentace takto přímo nevyužijeme;
    Xerces nám některé z nich poskytne později skrze reference jako globálně definované typy, atributy, elementy a jejich skupiny.
Při vykreslování tedy vůbec nebudeme muset pracovat s komponentami definice skupiny atributů
    (_Attribute group definition_), definice modelové skupiny (_Model group definition_) a deklarace notace
    (_Notation declaration_), které jsou dostupné pouze ze schématu, a nebudeme potřebovat ani anotace (_Annotation_).

[[PROCESS-ELEMENT-DECLARATIONS]]
=== Zpracování kolekce deklarací elementů

Kolekce deklarací elementů (v Xercesu obalené obecnou třídou [.class]`XSNamedMap`).

Metoda [.method]`processElementDeclarations`([.class]`XSNamedMap`[.parameter]`map`) provádí zpracování globálních
deklarací elementů.Metoda obsahuje cyklus.

. Prochází se kolekcí deklarací elementů:

.. Pro každý prvek kolekce se volá [.method]`processElementDeclaration`([.parameter]`elementDeclaration`, `null`)
    [<<PROCESS-ELEMENT-DECLARATION>>]. První parametr je konkrétní deklarace elementu (_Element declaration_), druhý je řetězec vyjadřující kardinalitu elementu. V případě globální deklarace má vždy hodnotu `null`.

[[PROCESS-ELEMENT-DECLARATION]]
=== Zpracování deklarace elementu
footnote:[http://www.w3.org/TR/xmlschema-1/#cElement_Declarations]

Deklarace elementu (_Element declaration_, v Xercesu třída [.class]`XSElementDeclaration`) umožňuje:

* lokální validaci hodnot informační položky element za použití definice typu;
* specifikování defaultních nebo fixních hodnot pro informační položku element;
* zajištění jedinečnosti hodnot a nastavení referenčních omezení v rámci hodnot příbuzných elementů a atributů;
* kontrolování vzájemné nahraditelnosti elementů pomocí mechanismu substitučních skupin (_element substitution groups_).

Metoda [.method]`processElementDeclaration`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`,
    [.class]`String`[.parameter]`cardinality`) zpracuje deklaraci elementu:

. Dojde k vytvoření symbolu <<SYMBOL-ELEMENT>> a jeho připojení na odpovídající místo stromové struktury.
    U symbolu je třeba nastavit základní informace, poskytované přímo objektem [.parameter]`elementDeclaration`,
    ale také některé dodatečné informace, například řetězec s typem elementu, získaný voláním pomocné metody
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>], a řetězec uvádějící
    minimální a maximální počet výskytů, získaný z parametru [.parameter]`cardinality`.
    Popis jednotlivých položek naleznete u grafického návrhu symbolu `element`.

. Zjišťuje se, zda se stejná deklarace nevyskytuje mezi předky této deklarace.
    Došlo by k zacyklení a vykreslování modelu by se nikdy řádně neukončilo. Kontrolu provádí metoda
    [.method]`processLoop`([.class]`XSElementDeclaration`[.parameter]`elementDeclaration`),
    která má za úkol v případě objevení cyklu připojit symbol <<SYMBOL-LOOP>> a zastavit zpracování následníků.

. Pokud má element komplexní datový typ, proběhne na tomto místě zpracování jeho definice.
    To obstarává metoda [.method]`processComplexTypeDefinition`([.parameter]`complexTypeDefinition`) [<<PROCESS-COMPLEX-TYPE>>]

. Bude volána pomocná metoda [.method]`processIdentityConstraints`([.parameter]`IdentityConstraints`)
    [<<PROCESS-IDENTITY-CONSTRAINTS>>], parametrem jsou všechna identitní omezení definovaná v rámci této deklarace.


[[PROCESS-ATTRIBUTE-USES]]
=== Zpracování kolekce užití atributů

Kolekce užití atributů (v Xercesu obalené obecnou třídou [.class]`XSObjectList`).

Metoda [.method]`processAttributeUses`([.class]`XSObjectList`[.parameter]`attributeUses`) provádí zpracování kolekce užití atributů.
Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]`processAttributeUse`([.parameter]`attributeUse`)
    [<<PROCESS-ATTRIBUTE-USE>>]. Parametr je konkrétní užití atributu (_Attribute use_).

[[PROCESS-ATTRIBUTE-USE]]
=== Zpracování užití atributu{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#cAttributeUse]

Užití atributu (_Attribute use_, v Xercesu třída [.class]`XSAttributeUse`) je pomocná komponenta,
která kontroluje výskyt a defaultní chování deklarace atributu.
Pro deklaraci atributu plní v rámci komplexního typu podobnou úlohu jako částice (_Particle_) pro deklaraci elementu.

Metoda [.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`)
slouží ke zpracování užití atributu a zároveň i samotné deklarace atributu:

. Na tomto místě proběhne zpracování deklarace atributu [<<PROCESS-ATTRIBUTE-DECLARATION>>].


[[PROCESS-ATTRIBUTE-DECLARATION]]
=== Zpracování deklarace atributu
footnote:[http://www.w3.org/TR/xmlschema-1/#cAttribute_Declarations]

Deklarace atributu (_Attribute declaration_, v Xercesu třída [.class]`XSAttributeDeclaration`) umožňuje:

* lokální validaci hodnot informační položky atribut za použití definice jednoduchého typu;
* specifikování defaultních nebo fixních hodnot pro informační položku atribut.

Pro jednoduchost je deklarace atributu zpracována uvnitř metody
[.method]`processAttributeUse`([.class]`XSAttributeUse`[.parameter]`attributeUse`) [<<PROCESS-ATTRIBUTE-USE>>].

. Dojde k vytvoření symbolu <<SYMBOL-ATTRIBUTE>> a jeho připojení do stromové struktury.
    Předtím se musí zjistit základní informace, poskytované přímo deklarací atributu,
    a také dodatečná informace o typu atributu, získaná voláním pomocné metody
    [.method]`getTypeString`([.parameter]`typeDefinition`) [<<PROCESS-SIMPLE-TYPE>>].
    Popis jednotlivých položek naleznete u grafického návrhu symbolu `attribute`.


[[PROCESS-WILDCARD]]
=== Zpracování divoké karty
footnote:[http://www.w3.org/TR/xmlschema-1/#Wildcards]

Divoká karta (_Wildcard_, v Xercesu třída [.class]`XSWildcard`)
umožňuje validaci informačních položek element a atribut, závisející na jmenném prostoru, ale nezávislou na lokálním jméně.

Metoda [.method]`processElementWildcard`([.class]`XSWildcard`[.parameter]`wildcard`,
[.class]`String`[.parameter]`cardinality`) slouží ke zpracování divoké karty pro element:

. Vytvoří symbol <<SYMBOL-ANY>> a připojí ho na odpovídající pozici ve stromové struktuře.
    Pomocná metoda [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů,
    parametr `cardinality` dodá informaci o minimálním a maximálním počtu výskytů.

Metoda [.method]`processAttributeWildcard`([.class]`XSWildcard`[.parameter]`wildcard`)
slouží ke zpracování divoké karty pro atribut:

. Vytvoří symbol <<SYMBOL-ANY-ATTRIBUTE>> a připojí ho na odpovídající pozici ve stromové struktuře.
    Pomocná metoda [.method]`getNamespaceString`([.class]`XSWildcard`[.parameter]`wildcard`)
    umožní sestavit řetězec, uvádějící omezení jmenných prostorů.


[[PROCESS-SIMPLE-TYPE]]
=== Zpracování definice jednoduchého typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Simple_Type_Definitions]

Definice jednoduchého typu (_Simple type definition_, v Xercesu třída [.class]`XSSimpleTypeDefinition`)
umožňuje omezení znakových informačních položek – dětí informačních položek element a atribut.

Pomocná metoda [.method]`getTypeString`([.class]`XSTypeDefinition`[.parameter]`typeDefinition`)
je volána při zpracování deklarací elementů a atributů.
U jednoduchého typu je pouze třeba zjistit název, nebo název základního typu a ten zobrazit jako typ elementu / atributu.

. Pokud je typ pojmenovaný (může být i komplexní), vrátí jméno typu.
. Pokud je typ anonymní a zároveň je jednoduchý, vrátí jméno základního typu, ze kterého je tento typ odvozen.
. Jinak vrátí `null`.


[[PROCESS-COMPLEX-TYPE]]
=== Zpracování definice komplexního typu
footnote:[http://www.w3.org/TR/xmlschema-1/#Complex_Type_Definitions]

Definice komplexního typu (_Complex type definition_, v Xercesu třída [.class]`XSComplexTypeDefinition`) umožňuje:

* omezení informačních položek element, přidáním deklarací atributů, určujících výskyt a obsah atributů;
* omezení informačních položek element tak, že musí mít buď prázdný obsah, nebo musí vyhovět specifikovanému
    obsahu smíšenému, nebo tvořenému pouze elementy; nebo omezuje znakové informační položky tak,
    aby vyhověly specifikované definici jednoduchého typu;
* využití mechanismu hierarchie definic typů (_Type definition hierarchy_)
    k odvození komplexního typu z jiného jednoduchého či komplexního typu;
* specifikování příspěvků k post-schema-validation infosetu elementů;
* omezení možnosti odvozovat další typy z tohoto komplexního typu;
* kontrolovat nahrazování elementů odvozeného typu za elementy deklarované v modelu obsahu,
    který je tohoto komplexního typu.

Definice komplexního typu je zpracována metodou [.method]`processComplexTypeDefinition`
    ([.class]`XSComplexTypeDefinition`[.parameter]`complexTypeDefinition`).

. Zjistí se, zda definice obsahuje částici (_Particle_), pokud ano, volá se metoda
    [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Parametrem je částice získaná z definice komplexního typu.
. Volá se pomocná metoda [.method]`processAttributeUses`([.parameter]`attributeUses`) [<<PROCESS-ATTRIBUTE-USES>>],
    parametrem je kolekce užití atributů.
. Pokud je definována divoká karta (_Wildcard_) pro atributy, zavolá se metoda [.method]`processAttributeWildcard`
    ([.parameter]`wildcard`) [<<PROCESS-WILDCARD>>]. Parametrem je divoká karta získaná z definice komplexního typu.


[[PROCESS-IDENTITY-CONSTRAINTS]]
=== Zpracování kolekce identitních omezení

Kolekce deklarací identitních omezení (v Xercesu obalené obecnou třídou [.class]`XSNamedMap`).

Metoda [.method]`processIdentityConstraints`([.class]`XSNamedMap`[.parameter]`identityConstraints`)
provádí zpracování deklarací identitních omezení. Metoda obsahuje cyklus.

. Prochází se kolekcí:

.. Pro každý prvek kolekce se volá metoda [.method]`processIdentityConstraintDefinition`
    ([.parameter]`identityConstraintDefinition`) [<<PROCESS-IDENTITY-CONSTRAINT>>].
    Parametrem je konkrétní definice identitního omezení (_Identity-constraint definition_).


[[PROCESS-IDENTITY-CONSTRAINT]]
=== Zpracování definice identitního omezení
footnote:[http://www.w3.org/TR/xmlschema-1/#cIdentity-constraint_Definitions]

Definice identitního omezení (_Identity-constraint definition_, v Xercesu třída [.class]`XSIDCDefinition`)
zajištuje jedinečnost a referenční omezení v rámci hodnot množiny elementů a atributů.

Metoda [.method]`processIdentityConstraintDefinition`
([.class]`XSIDCDefinition`[.parameter]`identityConstraintDefinition`)
má na starost zpracování definice identitního omezení.

. Zjistí se kategorie této definice:

.. Pokud jde o unikátní klíč (`unique`), vytvoří se symbol <<SYMBOL-UNIQUE>>.
.. Pokud jde o primární klíč (`key`), vytvoří se symbol <<SYMBOL-KEY>>.
.. Pokud jde o cizí klíč (`keyref`), vytvoří se symbol <<SYMBOL-KEYREF>>.
. Vytvoří se symbol <<SYMBOL-SELECTOR>>.
. Prochází se kolekcí polí (`field`):

.. Pro každý prvek kolekce se vytvoří symbol <<SYMBOL-FIELD>>.

Potřebné informace pro vykreslení všech symbolů poskytne přímo objekt [.parameter]`identityConstraintDefinition`.
Jejich přehled naleznete u návrhu jednotlivých symbolů.
Každý ze symbolů je připojen na odpovídající místo stromové struktury.

[[PROCESS-PARTICLES]]
=== Zpracování kolekce částic

Kolekce částic (v Xercesu obalené obecnou třídou [.class]`XSObjectList`).

Metoda [.method]`processParticles`([.class]`XSObjectList`[.parameter]`particles`) provádí zpracování kolekce částic.
Metoda obsahuje cyklus:

. Prochází se kolekcí částic:

.. Pro každý prvek kolekce se volá [.method]`processParticle`([.parameter]`particle`) [<<PROCESS-PARTICLE>>].
    Parametrem je konkrétní částice (_Particle_).


[[PROCESS-PARTICLE]]
=== Zpracování částice
footnote:[http://www.w3.org/TR/xmlschema-1/#cParticles]

Částice (_Particle_, v Xercesu třída [.class]`XSParticle`) přidává dodatečné informace o minimálním a 
maximálním počtu výskytů k definici modelu obsahu.

Metoda [.method]`processParticle`([.class]`XSParticle`[.parameter]`particle`) zpracuje částici následujícím způsobem:

. Pomocná metoda [.method]`getCardinalityString`([.class]`XSParticle`[.parameter]`particle`)
    sestaví řetězec `cardinality`, obsahující informaci o minimálním ([.property]`minOccurs`)
    a maximálním ([.property]`maxOccurs`) počtu výskytů částicí obaleného termínu ([.property]`term`).
. Zavolá pomocnou metodu [.method]`processTerm`([.parameter]`term`, [.parameter]`cardinality`) [<<PROCESS-TERM>>],
    která termín zpracuje, a pošle jí i řetězec `cardinality`.


[[PROCESS-TERM]]
=== Zpracování termínu

Termín (_Term_, v Xercesu třída [.class]`XSTerm`) je obecná vlastnost zastupující modelovou skupinu,
deklaraci elementu, nebo divokou kartu pro elementy.

Metoda [.method]`processTerm`([.class]`XSTerm`[.parameter]`term`, [.class]`String`[.parameter]`cardinality`)
provádí tento algoritmus:

. Zjistí se typ termínu:

.. Pokud se jedná o modelovou skupinu (_Model group_), volá se metoda
    [.method]`processModelGroup`([.parameter]`modelGroup`, [.parameter]`cardinality`) [<<_process_model_group>>].
    Prvním parametrem je termín – modelová skupina, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o deklaraci elementu (_Element declaration_), volá se [.method]`processElementDeclaration`
    ([.parameter]`elementDeclaration`, [.parameter]`cardinality`) [<<PROCESS-ELEMENT-DECLARATION>>].
    Prvním parametrem je termín – deklarace elementu, druhým parametrem se předává dál informace o kardinalitě.

.. Pokud jde o divokou kartu (_Wildcard_) pro elementy, volá se metoda [.method]`processElementWildcard`
    ([.parameter]`wildcard`, [.parameter]`cardinality`) [<<PROCESS-WILDCARD>>].
    Prvním parametrem je termín – divoká karta, druhým parametrem se předává dál informace o kardinalitě.


[[_process_model_group]]
=== Zpracování modelové skupiny
{blank}footnote:[http://www.w3.org/TR/xmlschema-1/#Model_Groups]

Modelová skupina (_Model group_, v Xercesu třída [.class]`XSModelGroup`).
Pokud není definováno, že mají být děti informační položky element prázdné,
nebo že mají vyhovovat určité definici jednoduchého typu, může být obsah posloupnosti dětí informační položky element
specifikován detailněji pomocí modelové skupiny.
Díky tomu, že součástí částice může být modelová skupina a modelová skupina obsahuje částice,
může modelová skupina nepřímo obsahovat jiné modelové skupiny.

Metoda [.method]`processModelGroup`([.class]`XSModelGroup`[.parameter]`modelGroup`,
[.class]`String`[.parameter]`cardinality`) provádí algoritmus:

. Zjistí se typ kompozitoru ([.property]`compositor`):

.. Pokud se jedná o kompozitor `all`, vytvoří se symbol <<SYMBOL-ALL>>.
.. Pokud jde o kompozitor `choice`, vytvoří se symbol <<SYMBOL-CHOICE>>.
.. Jinak jde o kompozitor `sequence`, vytvoří se symbol <<SYMBOL-SEQUENCE>>.

. Zavolá se pomocná metoda [.method]`processParticles`([.parameter]`particles`)
    [<<PROCESS-PARTICLES>>], parametrem je kolekce částic, obsažených uvnitř modelové skupiny.

U každého ze symbolů bude vypsán řetězec `cardinality` s informací o minimálním a maximálním počtu výskytů.
Vytvořený symbol je vždy připojen na odpovídající pozici stromové struktury.

[float]
==== Konečné uložení připravené struktury do SVG

Poté, co se dokončí procházení abstraktního datového modelu XML schématu a připravené symboly utvoří stromovou
strukturu, dojde k uložení stromu do SVG souboru.
Nejprve se vypíše jakási hlavička s XML deklarací, doctypem, titulkem, přidá se skript, předem definované symboly a
popřípadě styl; následují jednotlivé symboly komponent.
Přesný průběh vypadá tak, že se vezme kořenový symbol, nastaví se u něj správné rozměry a umístění na pomyslném plátně
a uloží se, totéž se pak opakuje se všemi dětmi a jejich potomky, až se dojde k listům stromu.
Tím jsou symboly vloženy do souboru a následuje už jen koncový tag `<svg>`

== Závěr

Cílem práce bylo navrhnout a implementovat aplikaci pro převod XML schématu do interaktivního diagramu ve formátu SVG.
Bylo proto třeba nastudovat principy, na kterých staví specifikace W3C XML schématu.
Ta silně odděluje abstraktní datový model od XML reprezentace.
Právě abstraktní datový model, jeho komponenty a vlastnosti komponent poskytují přímý a jednoduchý přístup k důležitým údajům.
Abych nemusel vše programovat od začátku, vybíral jsem mezi hotovými open source implementacemi modelu a zvolil
procesor tvořící součást parseru Xerces.
Ten vyhovuje specifikaci; zpřístupnil komponenty schématu a jejich struktury programovým prostředkům jazyka Java.

Dále bylo třeba rozhodnout se pro vhodný způsob zobrazení struktur definovaných schématem.
Zde jsem se inspiroval výstupy úspěšného XML editoru oXygen.
Z představy grafického modelu vzešel návrh tříd objektů – obecného abstraktního symbolu a konkrétních symbolů
komponent schématu –, návrh jejich vzhledu, parametrů a propojení i ve vazbě k zajištění interaktivity modelu.
Přitom bylo nutné alespoň v základu poznat možnosti formátu SVG.

Po načtení instance XML schématu do objektové reprezentace jazyka Java se spustí procházení těmito objekty a
začne se vytvářet stromová struktura definovaných symbolů.
Ta je nakonec uložena do SVG souboru.
Na něj jsou ale ještě vázány další technologie.
Především jde o ECMAScript, který je součástí souboru a provádí jeho zpracování při otevření v prohlížeči.
Zajišťuje interaktivitu reakcemi na události spuštěné pohybem a klikáním myši.
Aby skript mohl pracovat s elementy SVG dokumentu, potřebuje k nim získat přístup.
Přístup zajišťuje DOM úrovně 2.
Poslední technologií jsou kaskádové styly, které mohou tvořit součást SVG souboru nebo mohou být připojeny z
externího souboru a umožňují drobné úpravy výsledného vzhledu.

Na závěr mohu konstatovat, že se podařilo splnit cíl práce.
Praktickým produktem je funkční program, jehož výstupem je přehledný, interaktivní diagram zobrazující
strukturu XML souborů, vyhovujících schématu.
Konkrétně je to struktura použitelných elementů a atributů, jejich jména, jmenné prostory, datové typy,
kardinalita elementů, definované klíče atd.
Postromy symbolů lze zobrazovat a skrývat.
Dle mého názoru může diagram skutečně usnadnit orientaci a pochopení struktur, může tvořit kvalitní doplněk dokumentace.

I zde však existují určitá omezení.
První vyplývá z pomalé implementce SVG a ECMAScriptu v prohlížečích.
Projevuje se v pomalejší reakci na události a obecně v pomalejším vykreslování velkých diagramů.
V této oblasti lze jen doufat, že do budoucna vznikne lepší podpora.
Další problém se může vyskytnout při programovém zpracování schémat, popisujících velmi rozsáhlé struktury.
Může dojít k pádu aplikace v důsledku překročení paměťového prostoru.
Tento problém lze odstranit úpravou aplikace, vzhledem k prvnímu omezení však není nutné s úpravou moc spěchat.

Tím se dostávám k faktu, že aplikace včetně zdrojových kódů bude šířena jako svobodný software.
Momentálně je dostupná na přiloženém CD (viz <<_CD>>) a na webové stránce http://st.vse.cz/~XSLAV14/.
To přináší možnost budoucího rozvoje aplikace v podobě vylepšování nebo rozšiřování funkčnosti.
Například by šla přidělat tlačítka pro zoom in a zoom out; rozšířit program o podporu dalších schémových jazyků
(pokud vím, je jejich vizualizace předmětem jiných bakalářských prací);
nebo integrovat do systému pro generování kompletních dokumentací.

:sectnums!:

[bibliography]
== Literatura

[bibliography]
[float]
=== Hlavní
- [[[XSD0,1]]] Fallside, D. C., Walmsley, P. a kol.:
    _XML Schema Part 0: Primer Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-0/

- [[[XSD1,2]]] Thompson, H. S., Beech, D., Maloney, M., Mendelsohn, N. a kol.:
    _XML Schema Part 1: Structures Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-1/

- [[[XSD2,3]]] Biron, P. V., Malhotra, A. a kol.:
    _XML Schema Part 2: Datatypes Second Edition_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xmlschema-2/

- [[[XSD-VLIST,4]]] van der Vlist, E.:
    _Using W3C XML Schema. XML.com, 2001._
    Dostupný z WWW: http://www.xml.com/pub/a/2000/11/29/schemas/part1.html?page=1

- [[[SVG,5]]] Ferraiolo, J., Fujisawa, J., Jackson, D.: Scalable Vector Graphics (SVG) 1.1 Specification
    [online]. W3C, 2003. Dostupný z WWW: http://www.w3.org/TR/SVG/

[bibliography]

[float]
=== Vedlejší a doplňková
- [[[XML,6]]] Bray, T., Paoli, J., Sperberg-McQueen, C. M., Maler, E., Yergeau, F. a kol.:
    _Extensible Markup Language (XML) 1.0 (Fourth Edition)_
    [online]. W3C, 2006. Dostupný z WWW: http://www.w3.org/TR/REC-xml/

- [[[INFOSET,7]]] Cowan, J., Tobin, R.:
    _XML Information Set (Second Edition)_
    [online]. W3C, 2004. Dostupný z WWW: http://www.w3.org/TR/xml-infoset/

- [[[NAMESPACE,8]]] Bray, T., Hollander, D., Layman, A., Tobin, R.:
    _Namespaces in XML 1.0 (Second Edition)_
    [online]. W3C, 2006. Dostupný z WWW: http://www.w3.org/TR/REC-xml-names/

- [[[DOM1,9]]] Wood, L. a kol.:
    _Document Object Model (DOM) Level 1 Specification_
    [online]. W3C, 1998. Dostupný z WWW: http://www.w3.org/TR/REC-DOM-Level-1/

- [[[DOM2,10]]] Wood, L. a kol.:
    _Document Object Model (DOM) Level 2 Core Specification_
    [online]. W3C, 2000. Dostupný z WWW: http://www.w3.org/TR/DOM-Level-2-Core/

- [[[CSS,11]]] Lie, H. W., Bos, B.:
    _Cascading Style Sheets, level 1_
    [online]. W3C, 1996. Dostupný z WWW: http://www.w3.org/TR/CSS1/

- [[[M254,12]]] Hall, W., Keynes, M.:
    _M254 Java everywhere_
    [online]. The Open University, 2005. Dostupný z WWW: http://computing.open.ac.uk/m254/

:sectnums:

:sectnums!:

[appendix]
== Termíny
[glossary]
API:: Application Programming Interface,
    rozhraní aplikačních programů. Sada procedur, funkcí nebo tříd
    určité knihovny, programu nebo jádra operačního systému, která může
    být využita v aplikacích.

CSS:: Cascading Style Sheets, kaskádové styly.
    Jednoduchý mechanismus pro přidání grafické úpravy webovým
    dokuentům. Standard organizace W3C mimo jiné v <<CSS>>.

Data binding:: Převod dat mezi různými formáty. Například mezi XML dokumenty,
    objekty objektově orientovaných systémů a relačními tabulkami
    databázových systémů.

DOM:: Document Object Model, objektový model
    dokumentu. Rozhraní nezávislé na platformě a jazyku, které umožňuje
    programům a skriptům dynamický přístup k obsahu, struktuře a stylu
    dokumentu a jeho editaci. Poskytuje objektově orientovanou
    reprezentaci XML nebo HTML dokumentu. Specifikace W3C v <<DOM1>>, <<DOM2>> a dalších.

DTD:: Document Type Definition, definice typu
    dokumentu. DTD poskytuje nástroje pro definování povolených struktur
    elementů a atributů, umožňuje stanovení implicitních hodnot
    atributů. V rámci DTD lze také definovat znovupoužitelný obsah
    (entity) a dodatečné informace (notace). Specifikace je součástí
    doporučení organizace W3C o XML – <<XML>> a
    další.

ECMAScript:: Skriptovací (programovací) jazyk, standardizován organizací
    Ecma International ve specifikaci
    ECMA-262. Je široce používán na webu a bývá
    často označován jako JavaScript nebo JScript, podle hlavních
    dialektů tohoto jazyka.

Framework:: Základní konceptuální struktura užívaná k řešení nebo zaměření
    se na komplexní problémy. V oblasti softwaru se často jedná
    o knihovny, podpůrné programy, návrhové vzory a doporučené postupy.
    Framework řeší typické úlohy, které jsou ve většině aplikací shodné,
    a usnadňuje tak vývoj.

HTML:: HyperText Markup Language, hypertextový
    značkovací jazyk. Jazyk pro tvorbu webových stránek, aplikace SGML.
    Specifikaci vydala organizace W3C.

Informační položka:: Information item. Představuje uzel
    stromové struktury XML infosetu. Specifikace <<INFOSET>> definuje jedenáct různých typů položek. Každá
    má určité vlastnosti jako je rodičovský element, lokální jméno atd.
    V této práci se zmiňuji o znakové informační položce, informační
    položce element a atribut.

Infoset:: XML Information Set je abstraktní datový
    model XML dokumentu, skládá se z jednotlivých informačních položek.
    Specifikace W3C <<INFOSET>>.

Java:: Objektově orientovaný, silně typový, na platformě nezávislý
    programovací jazyk od společnosti Sun Microsystems.

Namespace:: Jmenný prostor. XML poskytuje jednoduchou metodu pro
    kvalifikování jmen elementů a atributů jejich zařazením do jmenného
    prostoru s URI identifikátorem. Specifikace W3C <<NAMESPACE>>.

Parsování:: Analýza předložených dat a vyhledávání prvků odpovídajících
    definici určitého jazyka. Obvykle jde o syntaktickou analýzu
    zdrojových kódů napsaných v daném programovacím jazyce.

PSVI:: Post Schema Validation Infoset, infoset
    po validaci dokumentu oproti schématu. Je to infoset XML dokumentu
    rozšířený o informace o datových typech položek. Příspěvky k PSVI
    jsou definovány ve specifikaci XML schématu <<XSD1>>
    a <<XSD2>>.

Renderování:: Rendering, proces, při němž se vykresluje
    obraz ze zadaných dat.

SAX:: Simple API for XML, jednoduché aplikační
    rozhraní pro XML. Poskytuje mechanismus pro čtení dat z XML
    dokumentů. Čtení probíhá sekvenčně a je založeno na událostech
    (přečtení počátečního tagu, přečtení ukončujícího tagu atd.) Není
    proto možná modifikace struktury dokumentu, na rozdíl od DOM.

SVG:: Scalable Vector Graphics, škálovatelná
    vektorová grafika. SVG je jazyk pro popis dvourozměrné grafiky a
    grafických aplikací pomocí XML. Základ vývoje tvoří specifikace SVG
    1.1, vydaná jako doporučení konsorcia W3C 14. ledna 2003 <<SVG>>.

Tag:: Značka vymezující začátek a/nebo konec elementu.

Validace:: Ověření shody XML dokumentu se schématem.

W3C:: World Wide Web Consortium. Zabývá se
    vývojem interoperabilních technologií – specifikací, směrnic,
    softwaru a nástrojů – s cílem sjednotit používané technologie
    a dosáhnout plného rozvoje a využití možností webu.

XHTML:: Extensible HyperText Markup Language,
    rozšiřitelný hypertextový značkovací jazyk. Jazyk pro tvorbu
    webových stránek, aplikace XML. Specifikaci vydala organizace
    W3C.

XML:: Extensible Markup Language, rozšiřitelný
    značkovací jazyk. Umožňuje vývojářům vytvářet vlastní formáty pro
    uchování a sdílení dat. Specifikaci vydalo konsorcium W3C, <<XML>> a další.

XML schéma:: XML schémata poskytují prostředky pro definování struktury,
    obsahu a sémantiky XML dokumentů. XML schéma bylo schváleno jako
    doporučení organizace W3C 2. května 2001 a druhá, upravená verze
    byla vydána 28. října 2004 <<XSD0>>, <<XSD1>>, <<XSD2>>.


:sectnums:

:sectnums!:

[appendix]
[[_CD]]
== Obsah CD-ROM

Součástí této práce je přiložený CD-ROM s textem práce, zdrojovými kódy a hotovou aplikací.
Poslední verze bude přístupná na webové stránce: http://st.vse.cz/~XSLAV14/.
Konkrétně na CD naleznete následující strukturu adresářů a souborů:

. [.path]_/thesis_ – adresář týkající se psaní bakalářské práce, obsahuje:
** [.path]_/images_ – složka použitých obrázků kromě symbolů komponent schématu
** [.path]_/symbols_ – složka s obrázky symbolů komponent schématu ve formátu SVG
** [.path]_thesis.xml_ – vlastní text práce ve formátu DocBook
** [.path]_thesis.xsl_, [.path]_tp-fo.xsl_ – styly upravující standardní výstup DocBooku
** [.path]_kizi.pdf_ – logo katedry pro titulní stranufootnote:[Upravené styly a logo katedry pochází ze stránek Jiřího Koska, věnovaných výuce na VŠE: http://www.kosek.cz/vyuka/.]
** [.path]_thesis.pdf_ – vygenerované PDF s touto prací
. [.path]_/src_ – adresář zdrojových kódů Javy, struktura vychází ze zařazení tříd do balíčků
. [.path]_/res_ – adresář dalších zdrojů obsahující:
** [.path]_/examples_ – složka s příklady XSD vstupů
** [.path]_/licenses_ – složka s licencemi parseru Xerces
** [.path]_readme.txt_ – textový dokument, popisuje uživatelské rozhraní
. [.path]_/lib_ – adresář obsahuje implementaci parseru Xerces – [.path]_xercesImpl.jar_
. [.path]_/dist_ – složka s aplikací připravenou k použití, obsahuje:
** [.path]_/examples_ – překopírováno z adresáře [.path]_/res_
** [.path]_/licenses_ – překopírováno z adresáře [.path]_/res_
** [.path]_/lib_ – adresář knihoven:
... kopie souboru [.path]_xercesImpl.jar_ a případných dalších z adresáře [.path]_/lib_
... archiv s vlastní aplikací [.path]_xsdvi.jar_
** [.path]EXAMPLES.bat_ – spouští transformaci příkladů, schémat ze složky examples
** [.path]_readme.txt_ – překopírováno z adresáře [.path]_/res_
. [.path]_build.properties_ – nastavení vlastností využívaných v [.path]_build.xml_
. [.path]_build.xml_ – XML skript pro sestavovací program Ant


:sectnums:

:sectnums!:

[appendix]
[[EXAMPLES]]
== Příklad

=== XML schéma – ukázkový vstup

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">

    <xs:element name="contact" type="ContactType"/>

    <xs:complexType name="ContactType">
        <xs:sequence>
            <xs:element name="phone" type="xs:string"/>
            <xs:element name="address" type="AddressType"/>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="AddressType">
        <xs:sequence>
            <xs:element name="name" type="xs:string"/>
            <xs:element name="street" type="xs:string"/>
            <xs:element name="city" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

</xs:schema>
----

[[EXAMPLES-SVG-XML]]
=== SVG výstup (XML reprezentace)

[source, xml]
----
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN'
  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
<svg id='svg' onload='loadSVG();'
  xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<title>XsdVi</title>

<script type='text/ecmascript'><![CDATA[
  var efBoxes = [];
  var eSvg = null;
  function loadSVG() {
    efBoxes = getElementsByClassName('box', document.getElementsByTagName('g'));
    eSvg = document.getElementById('svg');
    expandAll();
  }

  function getElementsByClassName(sClass, nlNodes) {
    var elements = [];
    for (var i=0; i<nlNodes.length; i++) {
      if(nlNodes.item(i).nodeType==1
        && sClass==nlNodes.item(i).getAttribute('class')) {
        elements.push(nlNodes.item(i));
      }
    }
    return elements;
  }

  function show(sId) {
    var useElement = document.getElementById('s'+sId);
    var moveNext = false;
    var eBoxLast;
    var maxX = 500;

    if (notPlus(useElement)) {
      eBoxLast = document.getElementById(sId);
      setPlus(useElement);
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id)) {
          eBox.setAttribute('visibility', 'hidden');
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    else {
      setMinus(useElement);
      var skipDescendantsOf;
      for (var i=0; i<efBoxes.length; i++) {
        var eBox = efBoxes[i];
        if (moveNext) {
          move(eBoxLast, eBox);
        }
        else if (isDescendant(sId, eBox.id) && (!skipDescendantsOf
          || !isDescendant(skipDescendantsOf.id, eBox.id))) {
          eBox.setAttribute('visibility', 'visible');
          move(eBoxLast, eBox);
          if (nextClosed(eBox)) skipDescendantsOf = eBox;
        }
        else if (isHigherBranch(sId, eBox.id)) {
          move(eBoxLast, eBox);
          moveNext = true;
        }
        if (eBox.getAttribute('visibility') != 'hidden') {
          eBoxLast = eBox;
          x = xTrans(eBox);
          if (x > maxX) maxX = x;
        }
      }
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function collapseAll() {
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setPlus(useElement);
      if (eBox.id != '_1') eBox.setAttribute('visibility', 'hidden');
    }
    setHeight(400);
    setWidth(500);
  }

  function expandAll() {
    var eBoxLast;
    var maxX = 0;
    for (var i=0; i<efBoxes.length; i++) {
      var eBox = efBoxes[i];
      var useElement = document.getElementById('s'+eBox.id);
      if (useElement) setMinus(useElement);
      move(eBoxLast, eBox);
      eBox.setAttribute('visibility', 'visible');
      eBoxLast = eBox;
      var x = xTrans(eBox);
      if (x > maxX) maxX = x;
    }
    setHeight(yTrans(eBoxLast)+71);
    setWidth(maxX+300);
  }

  function makeVisible(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(hidden);
    hiddenVisibility(visible);
  }

  function makeHidden(sId) {
    var childNodes = document.getElementById(sId).childNodes;
    var hidden = getElementsByClassName('hidden', childNodes);
    var visible = getElementsByClassName('visible', childNodes);
    inheritVisibility(visible);
    hiddenVisibility(hidden);
  }

  function inheritVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'inherit');
    }
  }

  function hiddenVisibility(efElements) {
    for (var i=0; i<efElements.length; i++) {
      efElements[i].setAttribute('visibility', 'hidden');
    }
  }

  function nextClosed(eBox) {
    var useElement = document.getElementById('s'+eBox.id);
    return (useElement && !notPlus(useElement));
  }

  function isHigherBranch(sSerialLower, sSerialHigher) {
    var sLower = sSerialLower.split('_');
    var sHigher = sSerialHigher.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
      else if (Number(sHigher[i]) < Number(sLower[i])) return false;
    }
    return false;
  }

  function isOnHigherLevel(eBoxLower, eBoxHigher) {
    var sLower = eBoxLower.id.split('_');
    var sHigher = eBoxHigher.id.split('_');
    for (var i=0; i<sLower.length; i++) {
      if (Number(sHigher[i]) > Number(sLower[i])) return true;
    }
    return false;
  }

  function isDescendant(sSerialAsc, sSerialDesc) {
    return (sSerialDesc.length > sSerialAsc.length &&
      sSerialDesc.indexOf(sSerialAsc) === 0);
  }

  function getParent(eBox) {
    var serial = eBox.id.substring(0, eBox.id.lastIndexOf('_'));
    return document.getElementById(serial);
  }

  function move(eBoxLast, eBox) {
    if (!eBoxLast) return;
    if (isOnHigherLevel(eBoxLast, eBox)) {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+(yTrans(eBoxLast)+71)+')');
      var parent = getParent(eBox);
      var line = document.getElementById('p'+eBox.id);
      if (!parent || !line) return;
      line.setAttribute('y1', String(yTrans(parent)-yTrans(eBox)+23));
    }
    else {
      eBox.setAttribute('transform',
        'translate('+xTrans(eBox)+','+yTrans(eBoxLast)+')');
    }
  }

  function notPlus(eUseElement) {
    return (eUseElement.getAttributeNS('http://www.w3.org/1999/xlink',
      'href') != '#plus');
  }

    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#plus');
  }

  function setMinus(eUseElement) {
    eUseElement.setAttributeNS('http://www.w3.org/1999/xlink',
      'href', '#minus');
  }

  function setHeight(nHeight) {
    eSvg.setAttribute('height', nHeight);
  }

  function setWidth(nWidth) {
    eSvg.setAttribute('width', nWidth);
  }

  function yTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var y = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[1]);
    if(!y) y = 0;
    return y;
  }

  function xTrans(eBox) {
    var transform = eBox.getAttribute('transform');
    var x = Number(transform.substring(10,
      Number(transform.length)-1).split(',')[0]);
    if(!x) x = 0;
    return x;
  }
]]></script>

<defs>

<style type='text/css'><![CDATA[

svg {pointer-events: none;}
text {font-family: arial; font-size: 11px;}
line, polyline, polygon {fill: none; stroke: black;}

.strong {font-size: 12px; font-weight: bold;}
.small {font-size: 10px;}
.big {font-size: 15px; fill: #882222;}

.button {fill: white; stroke: black; pointer-events: all;}
.shadow {fill: #ccccd8; stroke: none;}
.connection {fill: none; stroke: #666666;}
.empty {fill: none; stroke: black;}
.filled {fill: black; stroke: none;}

.boxelement, .boxany, .boxattribute1, .boxanyattribute
  {fill: #FFFFBB; stroke: #776633; pointer-events: all;}
.boxattribute2
  {fill: #FFFFBB; stroke: #776633; pointer-events: all; stroke-dasharray: 2;}
.boxschema, .boxloop, .boxcompositor {fill: #E7EBF3; stroke: #666677;}
.boxselector, .boxfield, .boxidc {fill: #E0F7B7; stroke: #667733;}

.lax {fill: white; stroke: black;}
.skip {fill: #cc6666; stroke: black;}
.strict {fill: black; stroke: none;}

]]></style>

  <symbol class='button' id='plus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
    <line x1='6' y1='3' x2='6' y2='9'/>
  </symbol>
  <symbol class='button' id='minus'>
    <rect x='1' y='1' width='10' height='10'/>
    <line x1='3' y1='6' x2='9' y2='6'/>
  </symbol>

</defs>

<rect class='button' x='300' y='10' width='20' height='20'
  onclick='collapseAll()'/>
<line x1='303' y1='20' x2='317' y2='20'/>
<text x='330' y='20'>collapse all</text>
<rect class='button' x='400' y='10' width='20' height='20'
  onclick='expandAll()'/>
<line x1='403' y1='20' x2='417' y2='20'/>
<line x1='410' y1='13' x2='410' y2='27'/>
<text x='430' y='20'>expand all</text>

<g id='_1' class='box' transform='translate(20,50)'>
<rect class='boxschema' x='0' y='12' width='63' height='21'/>
<text x='5' y='27'><tspan class='big'>/ </tspan>schema</text>
<use x='62' y='17' xlink:href='#minus' id='s_1' onclick='show("_1")'/>
</g>

<g id='_1_1' class='box' transform='translate(128,50)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1")' onmouseout='makeHidden("_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>contact</text>
<text class='visible' x='5' y='41'>type: ContactType</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1' onclick='show("_1_1")'/>
</g>

<g id='_1_1_1' class='box' transform='translate(290,50)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1'
  onclick='show("_1_1_1")'/>
</g>

<g id='_1_1_1_1' class='box' transform='translate(395,50)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_1")'
  onmouseout='makeHidden("_1_1_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>phone</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2' class='box' transform='translate(395,121)'>
<rect class='shadow' x='3' y='3' width='117' height='46'/>
<rect class='boxelement' x='0' y='0' width='117' height='46'
  onmouseover='makeVisible("_1_1_1_2")'
  onmouseout='makeHidden("_1_1_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>address</text>
<text class='visible' x='5' y='41'>type: AddressType</text>
<line class='connection' id='p_1_1_1_2' x1='-35' y1='-48' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
<use x='116' y='17' xlink:href='#minus' id='s_1_1_1_2'
  onclick='show("_1_1_1_2")'/>
</g>

<g id='_1_1_1_2_1' class='box' transform='translate(557,121)'>
<rect class='boxcompositor' x='0' y='8' width='60' height='31' rx='9'/>
<circle cx='42' cy='14' r='2'/>
<circle cx='42' cy='23' r='2'/>
<circle cx='42' cy='32' r='2'/>
<text class='small' x='30' y='17'>1</text>
<text class='small' x='30' y='26'>2</text>
<text class='small' x='30' y='35'>3</text>
<line x1='42' y1='14' x2='42' y2='32'/>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
<use x='59' y='17' xlink:href='#minus' id='s_1_1_1_2_1'
  onclick='show("_1_1_1_2_1")'/>
</g>

<g id='_1_1_1_2_1_1' class='box' transform='translate(662,121)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_1")'
  onmouseout='makeHidden("_1_1_1_2_1_1")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>name</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_2' class='box' transform='translate(662,192)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_2")'
  onmouseout='makeHidden("_1_1_1_2_1_2")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>street</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' x1='-35' y1='23' x2='0' y2='23'/>
</g>

<g id='_1_1_1_2_1_3' class='box' transform='translate(662,263)'>
<rect class='shadow' x='3' y='3' width='87' height='46'/>
<rect class='boxelement' x='0' y='0' width='87' height='46'
  onmouseover='makeVisible("_1_1_1_2_1_3")'
  onmouseout='makeHidden("_1_1_1_2_1_3")'/>
<text class='hidden' visibility='hidden' x='5' y='13'>nillable: 0</text>
<text class='hidden' visibility='hidden' x='5' y='41'>abstract: 0</text>
<text class='strong' x='5' y='27'>city</text>
<text class='visible' x='5' y='41'>type: string</text>
<line class='connection' id='p_1_1_1_2_1_3'
  x1='-35' y1='-119' x2='-35' y2='-40'/>
<path class='connection' d='M-35,-40 Q-35,15 0,23'/>
</g>

</svg>
----

=== SVG výstup (grafická reprezentace)

[[MY-MODEL-APPENDIX]]
.Grafický výstup
image::images/model_my.svg[]


:sectnums:

